Programmiersprache Java + Java Programme

Hallo und herzlich willkommen zum Kurs „Grundlagen der Programmierung beziehungsweise zu unserem allerersten kleinen Video mit dem Thema „Programmiersprache, Java und Java-Programme. Generell ist der Sinn dieser Videos, dieses vielleicht ein bisschen erschlagende große Thema Programmierung beziehungsweise Java runterzubrechen in jeweils fünf bis zehnminütige kleine Einheiten. Und neben dieser tollen schwarzen Einstiegsfolie, die wir hier mitgebracht haben, werden wir dann klassischerweise so eine schöne weiße Einstiegsfolie mitbringen, die einfach nur motivieren soll, was es mit dem Thema auf sich hat beziehungsweise das Ziel des Videos einfach zusammenfassen soll. Heute, hatte ich gerade schon gesagt, schauen wir uns ein bisschen ganz kurz die Eigenschaften von Java an, der Programmiersprache, die wir uns in den nächsten Monaten, aber eigentlich auch in den nächsten Semestern ansehen werden und wollen uns dann anschauen, wie wir von Code, den wir schreiben, tatsächlich zu einem ausführbaren Programm kommen. Normalerweise wäre es so, dass wir nach dieser Folie direkt anfangen, in den Code zu springen und gemeinsam zu programmieren. Heute habe ich noch drei kleine Folien mitgebracht und wir programmieren dann im nächsten Video, in dem wir uns dann angucken, wie unser allererstes Java-Programm so aussieht. Die aktuelle Java-Version ist die Version 23. Zum Zeitpunkt Aus dem Punkt der Erstellung dieses Videos ist es zwei, drei Wochen her.

Das heißt, Mitte September 2024 rausgekommen. Java an sich ist aber natürlich schon deutlich älter und wurde zum allerersten Mal vor gut 30 Jahren, nämlich 1996, veröffentlicht. Wir hatten uns Wir haben uns in der allerersten Vorlesung angeguckt, welche Programmiersprachen in den letzten Jahrzehnten so beliebt waren und hatten auch da gesehen, okay, Java spielt irgendwie bei den ganz oben mit, sozusagen. Was einerseits natürlich daran liegt, dass Java aktiv irgendwie weiterentwickelt wird und auf der anderen Seite daran, dass Java in ganz völlig verschiedenen Anwendungsfeldern eingesetzt werden kann. Einerseits ganz klassisch in der Appentwicklung für Android, auf der anderen Seite aber auch in der Web-Entwicklung. Nicht unbedingt für die Oberflächen, die wir sehen, wenn wir im Internet unterwegs sind, sondern eher für die Komponenten, die sozusagen dahinter liegen, also zum Beispiel, Daten auszuwerten und so weiter. Wenn wir jetzt von unserer Sicht oder der Sicht, die wir in den nächsten Wochen, Monaten so einnehmen wollen, nämlich aus der Entwicklungssicht drauf gucken, handelt sich es bei Java eine objektorientierte Programmiersprache. Dieses Thema „Objektorientierung behandeln wir in den ersten Wochen noch nicht, sondern erst gegen Mitte des Semesters. Das heißt, wir werden da so ein bisschen drüber stolpern, lösen aber relativ zeitnah auch auf, was es damit genau auf sich hat.

Heben wir uns aber für die zweite Hälfte des Semesters auf. Eine andere Sache, die wir uns auch sehr bald sogar ansehen werden in den nächsten Videos, ist die Typisierung von Java. Java ist eine sogenannte streng typisierte Programmiersprache. Was es damit auf sich hat, sehen wir sofort in den folgenden Videos. Da will ich jetzt also gar nicht zu viel dazu sagen. An sich ist Java in seinem Sprachumfang relativ überschaubar, hat eine relativ klare Syntax. Dieses Wort „Synthax Das klären wir auch relativ bald auf, was es damit genau auf sich hat. Letzten Endes sagt dieser Stichpunkt hier nur aus, dass es in Java eben relativ explizite Anweisungen gibt, die ich schreiben kann und ich nicht unbedingt die Möglichkeit habe, was eine gute Sache ist erst mal, dass ich dieselbe Sache irgendwie auf zehn verschiedene Arten und Weisen schreiben könnte. Das heißt, dadurch ist Java eben relativ explizit und auch relativ einfach zu erlernen als erste Programmiersprache. Wenn wir jetzt von dieser Aus der Entwicklungssicht weggehen und vielleicht eher auf die Betriebssicht gehen, das heißt, uns fragen oder uns angucken, warum es sinnvoll sein kann, Java Programme laufen zu lassen bei mir, haben wir einerseits Java als ziemlich sichere Programmiersprache, unter anderem durch ein sogenanntes Sandbox-Prinzip, Es gibt, das heißt, Java-Anwendungen laufen in so einer isolierten Umgebung und dadurch, dass Java-Programme dann in so einer Isolation laufen, können sie nicht unbedingt viel Schaden anrichten.

Ansonsten ist Java ziemlich robust, ziemlich performant und erlaubt auch nicht unbedingt, wie alle anderen Programmiersprachen oder zumindest nicht wie jede Programmiersprache, Nebenläufigkeit. Das heißt, die Möglichkeit, Daten parallel oder zumindest pseudo-parallel in sogenannten Threads zu bearbeiten. Okay, wenn ich jetzt, wie wir im nächsten Video gemeinsam machen werden direkt, ein Java-Programm schreibe, also irgendwelchen Code schreibe, wird das erst mal, bevor ich es dann eben bei mir laufen lassen kann, vom Java-Compiler in Java-Bite-Code kompiliert. Der ist erst mal architekturneutral, das heißt, unabhängig vom Betriebssystem. Nun ist es aber ja so, dass wir auf völlig verschiedenen Betriebssystemen arbeiten. Also ich habe hier meinetwegen macOS, andere Leute haben Linux oder haben Windows und der ByteCode, den ich erzeugt habe, oder generell diese Programme sind natürlich nicht unbedingt untereinander kompatibel. Das heißt, aus diesem Byte Code wird von der JVM, von der Java Virtual Machine, dieser Byte Code wird genommen, interpretiert und dann in den jeweiligen Code für mein jeweiliges Betriebssystem übersetzt, also meinetwegen nativen Code für macOS oder nativen Code für Linux, für Windows, wie auch immer. Dieses Programm können wir dann tatsächlich bei uns auf unserem Rechner starten. Das heißt, wir schreiben sozusagen unabhängig vom Betriebssystem, auf dem wir uns befinden, Java Code und dann für uns relativ unsichtbar kümmert sich der Java Compiler beziehungsweise die Java VM, die Java Virtual Machine, darum, dass wir dieses Programm auf unserem jeweiligen konkreten Betriebssystem ausführen können.

Als kleiner Einstieg und dann würde ich sagen, gucken wir uns im nächsten Video mal an, wie so ein Java Programm überhaupt aussieht. Bis dann.  



"Hallo Welt!" (Unser erstes Java-Programm)

Hallo zusammen! Wir schauen uns jetzt unser allererstes Java-Programm an, das heißt wir schreiben auch unseren allerersten Code. Klassischerweise heißt das dann Hello World oder auf Deutsch Hallo Welt. Genau, das heißt wir gucken uns heute unser allererste Java-Datei an bzw. die sogenannte Main-Methode, was es damit auf sich hat, sehen wir sofort. Und wir werden dabei sehen, was man unter sogenannter Synth-Tax versteht.

Das haben wir im vorherigen Video schon mal kurz erwähnt und eben auf der anderen Seite auch, was es mit sogenannten Synth-Tax-Fehlern auf sich hat. Okay, ich würde sagen, wir legen direkt los. Ich habe hier mal so ein kleines Demo-VPL für mich zum Spielen angelegt und das ist so neu, dass ich noch nicht mal irgendeine Datei erstellt habe.

Das heißt das mache ich hier sofort. Ich lege hier eine neue Java-Datei an, der schlägt mir schon glorreiche Namen vor, die ich offenbar früher mal verwendet habe. Schweinsgalock.java-Supername machen wir jetzt nicht. Ich würde die Datei einfach mal start.java nennen, habe ich auch schon mal gemacht. Wichtig ist natürlich dieses Datei-Endung .java.

Wichtig ist auch, dass ich hier die Datei mit einem großen Buchstaben benenne und das liegt da dran. Wir müssen hier so ein bisschen vorgreifen, ohne zu tief reinzugehen, dass ich in Java klassischerweise beginnen muss mit public class und dann dem Namen, den ich hier eingegeben habe, auch hier natürlich große und Kleinschreibungen beachten, start. Das hat mit diesem Thema Objektorientierung zu tun.

Wir erinnern uns, Java ist eine objektorientierte Programmiersprache und das ist am Anfang natürlich schwierigen Bogen, um Objektorientierung zu machen, wenn man in einer objektorientierten Programmiersprache unterwegs ist. Deswegen gehört das so ein bisschen zu dem Teil der Sprache, den wir anfangs erstmal so ein bisschen akzeptieren, aber dann uns nach und nach erschließen im Laufe der kommenden Wochen. Okay, nach diesem public class in unserem Fall start, weil dieser Datei auch start.java heißt, setze ich geschweifte Klammern und das VPL ist hier auch schon so nett, so eine schließende geschweifte Klammer anzulegen, beziehungsweise hier auch so ein bisschen einzurücken. In diesen geschweiften Klammern steht sozusagen ein scope, ein Umfang sozusagen. Das wäre jetzt hier der Umfang von dieser public class start. Wie gesagt, das Hinterfragen wird es erstmal gar nicht so sehr. Und hier können wir jetzt den Startpunkt von unserem Java Code anlegen oder festlegen.

Das wäre die sogenannte Main-Methode. Hier gibt es, sag ich mal, die klassische veraltete Sündtags, wenn man so will, oder immer noch gültige Sündtags, aber Dates schon immer gab es sozusagen. Es gibt inzwischen auch in neueren Java-Versionen eine neue Sündtags, um die Main-Methode zu schreiben.

Das Problem ist nur, dass das im VPL nicht funktioniert, weil man dafür, weil diese neue Sündtags so ein experimentelles Release ist oder so ähnlich wird, das wird genannt von Java und das VPL das einfach noch nicht akzeptiert. Das heißt, hier zeige ich jetzt einmal die klassische, immer gültige sozusagen, Variante um die Main-Methode zu schreiben. Das heißt, den Einstieg in unser Java-Programm. Hier stoßen wir jetzt auch wieder auf so ein paar Begriffe, die wir erst mal ein bisschen ignorieren und ausklammern und uns dann im Laufe des Semesters erschließen. Und zwar sage ich Public, Static, Vault, Main. Main ist der Name, also der Name der Methode, die Main-Methode heißt Main. Und dann setze ich runde Klammern und sage String, Ecke geklammern, öffnen das umschließende Ecke geklammern, AX.

Und auch hier nach diesem langen Satzgefühl, den ich hier hingeschrieben habe, setze ich wieder geschweifte Klammern oder eine geschweifte Klammer und kriege hier so eine schließende geschweifte Klammer direkt erkennt. Das ist der Start unserer Main-Methode, das ist der Start unserer Java-Anwendung. Wie gesagt, es gibt noch eine neuere Sündtags, die akzeptiert das VPL aber nicht, kann ich gerne später nochmal ganz kurz zeigen.

Jetzt möchte ich aber auch natürlich irgendwas sehen, ich kann hier die Datei speichern und die Datei ausführen, sehe aber natürlich noch nicht viel. Das heißt, was ich hier einmal machen möchte, ist, irgendein Text auf diesem schwarzen Fenster, was wir gerade gesehen haben, auf der Konsole auszugeben. Und dafür schreibe ich System.out .println, Runde Klammern, nach diesen Runden Klammern ein Simikolon, das ist wichtig in Java ein Statement, also sowas wie eine Anweisung letzten Endes, durch so ein Simikolon abzuschließen. Und in die Runde Klammern kann ich jetzt den Text mit Anführungszeichen schreiben, den ich gerne auf meiner Konsole sehen würde.

Und wir hatten ja schon auf der ersten Folie stehen, Hallo Welt, also übernehme ich das jetzt einfach mal, speicher die Datei für das Ganze aus und sehe jetzt hier Hallo Welt, super. Wir haben jetzt hier bei diesem System.out .print noch Println stehen. Das sorgt dafür, dass wir automatisch nachdem dieser Text auf der Konsole ausgegeben wird, so ein Zeilenumbruch haben, das heißt, wenn ich mir das jetzt einfach mal kopiere und nochmal einfüge und hier dann vielleicht sage Hallo, Brock 1 in der zweiten Zeile, die Texte direkt untereinander ausgegeben werden. Es gibt auch noch die Möglichkeit hier dieses ln wegzulassen und dann eben entsprechend kein Zeilenumbruch zu haben. Das heißt, die Texte würden nebeneinander gezeigt werden.

Okay, so viel dazu. Wir haben natürlich bis jetzt sinnvollerweise nur gültigen Java Code geschrieben. Das heißt, wir haben der Java-Syntax gefolgt, die Java-Syntax, die Syntax der Programmiersprache Java legt fest, welchen Aufbau so ein Programm haben soll, was gültige Zeichen sind und so weiter und so fort. Das heißt, wenn ich jetzt hier zum Beispiel einmal auf der Tastatur ausrutsche, die Datei speicher und dann Versuch auszuführen, dann wird es hier heißen, beim Kompilieren ist ein Fehler aufgetreten. Dieses FSD, was auch immer ich da gerade reingehauen habe, ist irgendwas, womit Java nichts anfangen kann und dementsprechend der Code nicht kompilieren.

Das sieht es natürlich relativ logisch aus. Wir hatten vorhin gesagt, das ist ein ganz, ganz klassischer Fall, der einem auch später in der Programmierung immer noch mal passieren kann, dass man zum Beispiel so ein Symi-Colon vergisst, was dann natürlich auch keine gültige Java-Syntax mehr eigentlich ist. Also ich muss nicht auf der Tastatur ausrutschen, um sozusagen was zu machen, was nicht von Java kompiliert werden kann.

Wir probieren es mal aus. Ich habe jetzt hier wie gesagt so ein Symi-Colon gelöscht und würde auch hier angezeigt bekommen, dass eben eigentlich so ein Symi-Colon an der Stelle erwartet worden wäre und dass der Code deswegen nicht so wie wir es vorhin hatten in so diesem schicken schwarzen Fenster gestartet wird. Okay, also nehmen wir dieses Symi-Colon gerne hin.

Eine Sache, die ich abschließend noch zeigen möchte, ist ein Kommentar in Java. Wir haben jetzt einmal schön was auf der Konsole ausgegeben, also in diesem schwarzen Fenster was erscheint wird. In unserem Fall Hallo-Welt angezeigt. Ich habe dieses Hallo-Probe-1 wieder gelöscht. Jetzt kann es natürlich sein, dass ich mir zum Beispiel ran schreiben möchte, was dieser Code hier macht. Und da gibt es die Möglichkeit in Java. Es gibt verschiedene Möglichkeiten für Kommentare, aber ich zeige jetzt erstmal die hier, die ich auch persönlich eigentlich für eine ziemlich einfache halte, nämlich zwei solche Slashes und dann hier hinschreiben, was auch immer dieser Code gibt. Hallo-Welt auf der Konsole aus. Und dieser Kommentar hier, der ist jetzt nur für mich. Das heißt, wenn ich jetzt den Code speichere und ausfühle, zeigt jetzt hier immer noch so ein rotes X, aber es liegt an der VPL, die war ein bisschen langsam. Ja, sehe ich natürlich immer noch Hallo-Welt, aber habe mir hier so einen kleinen Kommentar angeschrieben und der Kommentar ist ein Kommentar. Ja, das heißt hier ist natürlich keine Java Syntags mehr erfordert, sondern das ist sozusagen eine Information für mich, die ich mir ran schreibe, um zum Beispiel meinen Code irgendwie besser nachvollziehen zu können.

Ich fasse nochmal ganz kurz zusammen. Wir haben in Java eine Datei oder wir legen eine Datei an. Die hat dann die Endung Punkt Java. Diese Datei hat einen Namen, der beginnt mit einem großen Buchstaben. Was es damit auf sich hat, gucken wir uns in, ich würde sagen, ein und ein halb Monaten ungefähr an. Das hat mit diesem großen Thema Objektorientierung zu tun, genauso wie hier diese erste Zeile, Public Class Start, Start, weil die Datei Start heißt.

Gucken wir uns alles an. Wichtig ist hier auch natürlich, dass genauso zu schreiben wie hier, sprich mit einem Großbuchstaben eingeläutet und alles andere klären wir dann irgendwann später im Laufe des Semesters. Durch diese geschweiften Klammern gebe ich immer einen Scope, also einen Umfang sozusagen an, in dem Fall der Umfang von dieser Public Class Start. Und in dieser Public Class Start haben wir hier die Main Methode deklariert, Public static void Main, String arcs.

Auch das ist eine relativ sperrige Syntags, die man oder die wir im Laufe des Semesters auch verstehen werden, die aber vielleicht anfangs so ein bisschen auswendig gelernt werden muss oder vielleicht noch nicht so ganz trivial erscheint. Aber da kommen wir hin. Und innerhalb dieser Main Methode haben wir jetzt angefangen, richtig in Anführungszeichen zu programmieren, also unsere ersten Sachen hinzuschreiben, die man auch schon wirklich nachvollziehen konnte, sprich einmal auf der Konsole einfach Hallo Welt ausgegeben. Wir haben dabei auch kennengelernt, was die Java Syntags ist bzw. was eben nicht die Java Syntags ist, also was passieren kann, wenn ich einen sogenannten Syntagsfehler begehe.

Und wir haben uns hier auch noch angeguckt, wie wir uns selber zum Beispiel Kommentare setzen können, die dann entsprechend auch vom Compiler ignoriert werden. Okay, so viel dazu. Bis zum nächsten Mal. Doch noch nicht ganz, ich hatte eine Kleinigkeit versprochen und am Ende des Videos gemerkt, dass ich sie nicht gezeigt habe. Und zwar hatte ich gesagt, es gibt eine neue Möglichkeit, um diese Main Methode zu schreiben, die wie gesagt nicht vom VPL unterstützt wird.

Ich wollte aber trotzdem einmal zeigen und zwar wäre die ganz einfach. Wir sparen uns den ganzen Kramen, den wir gemacht haben und sagen, Vault Main setzen dann runde Klammern und die geschweiften Klammern und könnten jetzt hier zum Beispiel System Out Print Line irgendwas hinschreiben, mit einem Semikolon am Ende speichern und das Ganze ausführen. Das Problem ist nur, dass VPL an der Stelle sagt, dass diese unbenannten Klassen ein Vorschaufeature sind, was standardmäßig deaktiviert ist. Also dass wir es letzten Endes nicht in VPL nutzen können, ohne weiteres und dementsprechend ja vielleicht später im Laufe des Semesters uns nochmal ansehen können, aber hier nicht unbedingt verwenden können.



Variablen und Datentypen I: Datentypen und ihre Wertebereiche, Initialisierung und Wertzuweisung

Hallo zusammen, wir machen weiter mit den Grundlagen der Programmierung bzw. mit Variablen und Datentypen Part 1.

Das ist ein Thema, was man irgendwie beliebig breite aufziehen könnte. Deswegen machen wir hier lieber zwei Videos draus und gucken uns hier erstmal an, was es für Datentypen in Java gibt, bzw. welche Wertebereiche dadurch abgedeckt werden können durch die einzelnen Datentypen, wollen dann natürlich auch irgendwelche Daten abspeichern in sogenannten Variablen, mit denen wir arbeiten möchten, machen noch einen kleinen Exkurs zur Binärschreibweise, die ist vielleicht auch schon bekannt, entweder aus Rechnernetze oder aus Mathe, schlimmstenfalls also eine Wiederholung an der Stelle, die aber erklärt, wie diese einzelnen Wertebereiche überhaupt zustande kommen und gucken uns zu guter Letzt an, was es mit sogenannten konstanten Variablen auf sich hat.

Ich würde sagen, wir legen direkt los, ich habe hier noch die VPL vom letzten Mal, diesmal aber ohne dieses System Outprint Line, stattdessen wollen wir ja hier heute oder in diesem Video Daten abspeichern. In sogenannten Variablen, bevor wir aber dazu kommen, vielleicht noch mal ganz kurz grauer Theorie, in Java haben wir sogenannte elementare Datentypen, auch genannt primitive Datentypen, das sind die, die wir uns jetzt angucken werden in den nächsten, ja, vier, fünf Wochen und im Gegensatz zu den elementaren Datentypen gibt es auch noch die sogenannten Referenzdatentypen, hier sind wir dann im Bereich der Objektorientierung und die gucken wir uns dann dementsprechend gegen Mitte des Semesters gemeinsam an. Okay, wir hatten auch schon gesehen oder gelernt, im ersten Video Java ist eine streng typisierte Programmiersprache und eine sehr explizite Programmiersprache, das klingt erstmal ein bisschen abstrakt, da würde ich aber jetzt hier direkt einsteigen. Streng typisiert heißt nämlich nichts anderes, als dass ich immer explizit sagen muss, mit welchem Datentypen wir es hier gerade zu tun haben. Das klingt auch noch ein bisschen abstrakt, deswegen zeige ich jetzt mal direkt an ein Beispiel. Wenn wir einen Datentypen abspeichern wollen, wollen wir einen Datentypen in eine Variable laden.

Eine Variable ist dabei nichts anderes als ein Platzhalter oder eine Box, wenn man sich ein bisschen bildlicher vorstellen kann. Und diese Box hat eben von vornherein einen festen Datentypen. Zum Beispiel könnte ich wahrheitswerte abspeichern. Ja, das ist der erste Datentypen, den wir entsprechend kennenlernen, auf Englisch Boolean, also ja oder nein, true oder false, war oder falsch. Und wenn ich so eine Variable vom Datentypen Boolean anlegen will, mache ich das indem ich hinschreib. Boolean, sprich den Datentypen und noch einen Namen, zum Beispiel MyBoole und mit einem Semikolon dieses Statement beende. Ja, hier die Schreibweise ist vielleicht ein bisschen komisch auf den ersten Blick. Wir beginnen mit einem kleinen Buchstaben und sozusagen nächsten Wörter trennen wir ab, indem wir einfach mit einem Großbuchstaben anfangen.

Das ist die sogenannte LowerCamelCase Schreibweise. Das ist die Konvention für solche Variablen in Java. Okay, jetzt haben wir eine Variable angelegt. Jetzt haben wir aber immer noch keinen Wert da drin und wollen vielleicht einen Wert zuweisen. Das kann ich machen, indem ich sage MyBoole, weiß ich doch bitte den Wert true, meine Dwingenzu. Was wir letztes Mal auch schon kennengelernt haben war dieses System OutPrintLine und hier könnte ich mir zum Beispiel den Wert der Variable MyBoole ausgeben lassen und würde true erwartungsgemäß auf der Konsole sehen.

Okay, super. Also ich an der Stelle gleich zeigen kann, ja, das ist jetzt in dem Fall auch viel einfacher. Ich muss das nicht in zwei Schritten machen, ich muss also nicht explizit die Variable erstmal anlegen und dann einen Wert zuweisen.

Ich kann alternativ das auch in einem Schritt machen, indem ich einfach sage, Boolean MyBoole ist gleich true, ja, das funktioniert also genauso. Was ich an der Stelle auch gleich zeigen will, was diese strenge Typisierung vielleicht gleich mal erklärt, ist der Versuch einfach einen anderen Datentypen hier abzulegen und ein kleiner Spoiler vielleicht an der Stelle zu einer Sache, die wir in spätestens vier Minuten sowieso gelernt haben. Wenig überraschend kann ich in Java auch Zahlen abspeichern.

Wenn ich jetzt aber hier versuchen würde, zum Beispiel dieser Variable MyBoole, die vom Datentypen Boolean ist, eine Zahl zuzuweisen und das Ganze dann zu kompellieren, komme ich nicht etwa zu dem System OutPrintLine, sondern das Programm wird gar nicht erst kompelliert und sagt eben, hier gibt es irgendwie inkompantible Datentypen, ja, und was das ist, gucken wir uns gleich an, kann nicht in Boolean konvertiert werden. Schlecht. Ja, das geht also nicht. Java zwingt uns also so gesehen, das ist eigentlich eine gute Sache, gerade für die erste Programmiersprache, den richtigen Datentypen oder den explizit angegebenen Datentypen eben zu verwenden. Okay, wir haben jetzt hier kennengelernt, Wahrheitswerte, ja, als einen primitiven Datentypen. Gucken uns an, was es sonst noch für primitive Datentypen gibt. Und ich würde hier mal weitermachen mit einem einzelnen Zeichen, also einem kleinen A oder einem Punkt oder was auch immer. Zeichen auf Englisch ist Character, der Datentyp heißt entsprechend K, manche Leute sagen, tschau, scheiden sich so ein bisschen die Geister, wie man das aussprechen möchte. Die Variable Datentyp Zeichen nenne ich jetzt einfach mal C und kann hier hier ein Wert zuweisen.

Es wird dann so ein Zeichen, umklammern wir mit den Single Quotes, also einfachen Anführungszeichen, die heißen in Java eben hier, handelt sich um ein einzelnes Zeichen. Zum Beispiel weiß ich nicht, das kleine A, ja, ich speichere das ab. Ich habe das System Outprint Line gelöscht, dementsprechend wird nichts ausgegeben, aber der Code kompiliert. Sehr schön.

Wenn ich jetzt hier versuchen würde, mehrere Zeichen reinzuschreiben, dann würden wir wieder so ein Compiler Fehler haben, weil es eben einfach nicht geht, weil durch diese Single Quotes genau ein Zeichen erwartet wird und der Datentyp Character, wie der Name eigentlich auch schon sagt, genau ein Zeichen eben abspeichern soll. Okay, so weit so einfach. Wir hatten gesagt, wir können in Java auch Zahlen abspeichern, wir haben das mal probiert in so einer Boolean Variable, das geht natürlich nicht, was aber geht, ist in entsprechenden Variablen für Zahlen. Das ist aber leider nicht ganz so einfach, zumindest auf den ersten Blick, wie man sich vorstellen könnte. Hier müssen wir nämlich erstmal unterscheiden in Ganzzahlen und Kommazahlen. Und als wäre das nicht schon, ja, schwierig genug, ich glaube, man kriegt es hin. Aber also wäre das nicht schon der erste Schritt, müssten wir hier auch nochmal unterscheiden zwischen verschiedenen Datentypen für Ganzenzahlen. Ich schreibe das schon mal hin, was es gibt. Ich bin erstmal wenig kreativ und leg jeweils eine Variable an, den Namen hat vom Datentypen oder den ersten Buchstaben einfach nur, Int, Short und, Beid, Short, Int und Long, so rum.

Und weißt ihr jeweils 1, 2, 3, 4 zu, wenn ich wenig kreativ bin. Jetzt kann man sich natürlich berechtigt, da weiße die Frage stellen, warum das ganze, ja, was hat es damit auf sich und hier muss man so ein bisschen in die Vergangenheit gucken, aber ist ja schon ein paar jährchen alt, wir hatten gesehen, 1996 wurde es zum ersten mal veröffentlicht, ist schon ein paar Jahre her und damals war Speicherplatz eben eine deutlich heitlere Sache als jetzt. Heutzutage macht es für meinen Laptop keinen merkbaren Unterschied, ob ich eine Variable in einem Byte abspeiche oder eben doch, beid ist der kleinste Datentyp hier, einen Long dafür nehme, das macht merkbar keinen Unterschied, ja, erst mal. Wir gucken uns gleich an, wo es natürlich einen Unterschied machen könnte, ja, wir gucken uns erst mal an, wie viel Speicher die jeweiligen Datentypen verbrauchen, hier wäre das ein Byte beziehungsweise 8-Bit, hier wären das 16-Bit, hier wären das 32-Bit, hier wären das 64-Bit, das ist eine Information, die jetzt vielleicht auch erst mal sehr technisch und abstrakt wird, wir gucken uns an, was das ganz konkret bedeutet und hier sind wir bei der sogenannten Bineerschreibweise 8-Bit, das heißt 8-0 oder 1er können einen Wertbereich darstellen von, ja, ja, 0 bis 256 beziehungsweise wenn ich 8 Plätze frei habe, ja, ich deutere das hier mal so an, 1, 2, 3, 4, 5, 6, 7, 8, ja, 8-0, das wäre jetzt die Zahl 0, wenn ich die letzte Zahl zu einer 1 mache, hätte ich jetzt zufälligerweise genau den Wert, den wir hier auch hingeschrieben haben und es gibt genau 256 Möglichkeiten, wie ich hier 0 und 1 anordnen kann und dadurch können genau 256 Werte gespeichert werden, das kann man sich so errechnen, dass man sagt hier ja 1 mal 2 hoch 0 plus 0 mal 2 hoch 1 plus 0 mal 2 hoch 2 und so weiter und sofort, der letzte hier ist 2 hoch 7 und wenn jetzt überall hier eine einstehen würde, hätte ich in den Wert 256, die Zahl 256, das heißt wir können 256 Werte darstellen mit diesem Byte, das heißt nicht etwa bis 256 oder bis 255, wenn man die 0 einbegreift, sondern wir fangen bei minus 128 an bis 127. Alternativ hier, ich gucke mir das jetzt ab, man könnte natürlich auch sagen, es sind 2 hoch 16 Werte, die genauen Zahlen, kann man sich ausrechnen, kann man auch einfach abgucken, das wäre minus 32.768 bis 32.767, ja die 0 ist immer inbegriffen, aber wir kommen halt dann immer genau auf 2 hoch 8 bzw.

2 hoch 16, 2 hoch 32, 2 hoch 64 Werte, die wir darstellen können. Okay, wir sehen hier natürlich schon einen Fall, wo es sinnvoll sein könnte oder wo wir wirklich gezwungen sind, einen Datentypen bewusst zu wählen, ja, INT ist auch klassischerweise so der Datentyp, den man wählt in der Programmierung für ganze Zahlen, INT hat ungefähr minus 2 Milliarden bis 2 Milliarden als Wertepereich, den er abdeckt, das heißt in der Regel sollte man damit zurechtkommen, vielleicht manchmal nicht, ja wenn ich jetzt zum Beispiel die Weltbevölkerung abspeichern will, muss ich halt einen Long nehmen, weil wir eben entsprechend mehr als 2 Milliarden Menschen haben und der Datentyp dafür nicht ausreicht. Das heißt auch wenn es merkbar keinen Unterschied macht, ob ich jetzt ein 8-Bit oder einen 64-Bit großen Datentypen verwende, macht es dann doch einen Unterschied entsprechend, wenn ich Werte abspeichern möchte, die ich gar nicht mehr darstellen kann durch den Datentypen. Okay, zum Gut anletzt haben wir die Komma Zahlen, hier gibt es auch zwei verschiedene Datentypen, der eine ist float, ich nenne den mal float F, der 32-Bit groß ist, der englischen Schreibweise haben wir ja immer so einen Punkt, ja statt einem Komma, das ist auch so ein häufiger Fehler, den man gerne mal macht, also 3.0 ist 3,0 oder 3.1 vielleicht ist ein bisschen eindeutiger, dass es hier dann eine Komma Zahl ist oder eine nicht ganze Zahl und auf der anderen Seite double, double hat 64-Bit, das heißt wir können hier größere Zahlen bzw. mehr Nachkommastellen auch abspeichern bei Bedarf und ich nehme jetzt mal ein Beispiel, 1,5 meine Dwegen bzw. 1,5, um Komma Zahlen darzustellen. Okay, so weit so gut, ich kann das hier auch einmal kompilieren und werde, ah, ich laufe hier einen kleinen Fehler, da kommen wir dann im nächsten Video dazu, ich lasse das hier mal unkommentiert stehen, dass ich hier noch dieses große F ran hänge, dann funktioniert das Ganze, es wird nicht ausgegeben, weil wir kein System Outprint-Line hier drin haben. Wir haben jetzt hier aber eine kleine Auflistung von allen Datentypen, ja ein Boolean vielleicht noch zur Vorständigkeit ist genau ein Bit groß, 0 oder 1, ja oder nein, ein Character kann genau 65.536 Zeichen darstellen, das heißt einfach nur 2 hoch 16, sprich 16 Bit groß und hier hatten wir gesagt, beim Float waren es 16 Bit, ah, sorry 32 Bit und beim Boolean, beim double, ich bin verwirrt und komme durcheinander, 32 Bit.

Okay, super. Wir können jetzt, das ist auch der Abschluss dann des Videos, ich bin schon wieder über der Zeit eigentlich, wir können, hatten wir uns vorhin angesehen, natürlich den Variablen auch neue Werte zuweisen, zum Beispiel machen wir so ein System Outprint-Line von meinetwegen dem D, das ist der Wert, der da unten steht, sprich die 1,5, ja dann wird 1,5 ausgegeben. In dem Moment, wo ich jetzt hier sage, D ist gleich, weiß ich nicht, 33,33, in dem Moment würde natürlich der Wert entsprechend neu gesetzt werden und ja, ich würde 33,33 auf der Konsole ausgegeben bekommen. Soweit wenig überraschend, jetzt kann es aber natürlich sein, dass es Werte gibt, die ich einfach nicht verändern möchte, ja also wo ich sage, okay, das soll jetzt auch, das soll jetzt auch niemanden in Versuchungen geraten, irgendwie den Wert zu überschreiben, das habe ich dem, da habe ich die Möglichkeit, indem ich ein sogenanntes Keyword Final davor setze, ich mache das hier mal an einem Beispiel, ich nehme das mal hier unten wieder weg und da stellt jetzt hier eine neue Variable und das wäre der Double P und P ist 3,14 irgendwas, es spielt jetzt keine große Rolle, die letzte Nachkommastelle, ja, wenn ich das so hinschreibe, ist das eine ganz normale Double Variable, sprich ich kann sie überschreiben, wenn ich jetzt aber hier dieses Keyword Final davor schreibe und dann versuchen würde, zu sagen, P ist gleich 6,7 ,8 meine Dwegen und dann versuchen würde das Ganze zu kompilieren, würde ich wieder in so ein Compiler Fehler laufen, weil es heißt Moment, hier wird versucht, ein Wert in der finalen Variable zuzuweisen und das geht nicht. Jetzt habe ich ein bisschen überzogen, das tut mir wahnsinnig leid und würde sagen, wir sehen uns beim nächsten Video, bis dahin.



Variablen und Datentypen II: Literale, Typ-Teilmengenbeziehung & Casting

Wir machen weiter mit Spaß mit Datentypen, also Variablen und Datentypen Part 2. Wir hatten ja vorhin schon im letzten Video angefangen und machen hier jetzt einfach weiter. Wir möchten uns angucken, was sind Literale und wie können wir mit verschiedenen Datentypen arbeiten bzw. vielleicht auch bei Bedarf Datentypen umwandeln.

Wir machen einfach genau da weiter, wo wir aufgehört haben. Wir hatten hier irgendwie für jeden Datentypen mal eine Beispielvariable angelegt und hier unten nochmal dieses Final Keyword gezeigt. Wir erinnern uns auch an eine Variable, die mit Final gekennzeichnet ist. Der können wir keinen neuen Wert zuweisen. Sprich, hier diese Zeile hat irgendwie viele Probleme gesorgt.

Dementsprechend schmeißen wir die jetzt einfach raus, um hier weiter machen zu können. Okay, was sind Literale? Literale sind nichts anderes als ein Wert in einem Programm, der ohne explizite Erklärung des Datentyps verwendet werden kann, was erstmal ein bisschen sperrig klingt und wenn man sich oben anguckt, dass wir eigentlich jeder Zeile angegeben haben, um was für ein Datentypen es sich handelt, irgendwie komisch wirkt, gucken wir uns sofort an. Ich möchte eine kleine Sache noch zeigen, die hier ganz gut reinpasst, die wir jetzt letztes mal nicht explizit gemacht haben, die aber vielleicht ganz spannend ist. Und zwar könnte ich ja auf die Idee kommen, hier wenn wir uns zum Beispiel den Wertbereich von einem Byte anschauen, also 1234 sein und versuchen das zu speichern, die 1234 liegt natürlich außerhalb dieser Wertemenge, die überhaupt durch ein Byte darstellbar ist. Und in dem Moment, wenn ich das versuchen würde auszuführen, würde es heißen Moment, wir haben hier Fehler, wir haben hier Fehler, wir haben inkompatible Datentypen. Wir würden von einem Int in ein Byte konvertieren und ja, das möchte er irgendwie nicht erlauben. Okay, spannende Sache mit dem Int. Also hier an der Stelle wird einfach geguckt, liegt die Zahl, die ich hier versuche abzuspeichern, in dem Wertbereich ja oder nein. Wir hatten gesagt, literale sind Werte, die wir ohne explizite Erklärung des Datentyps verwenden können. Oben haben wir hier oben immer ganze Zahlen verwendet, ohne groß drauf zu achten.

Wenn wir hier aber mal bei den Kommazahlen gucken, ist es so, dass wir beim Flow explizit einen F angeben mussten am Ende. Das liegt daran, dass als Standard Datentyp, wenn ich eine Kommazahl einfach angebe, das Programm davon ausgeht, dass es ein Double ist und ein Double ja aber 64-Bit groß sein kann, während ein Float nur 32-Bits zur Verfügung hat. Das heißt, in dem Moment, wo ich hier für einen Float, ich nenne es mal F2, meine ich wegen, versuche 3.1 .2 zuzuweisen, geht er hier davon aus, das ist ein Double, literal, ohne ein F dahinter, wird einfach davon ausgegangen, das ist ein Double und das geht natürlich nicht. Ich kann nicht einfach ein Double in ein Float reinspeichern. Hier müsste ich also dieses F hinschreiben, dann würde das Ganze funktionieren und der Code würde wieder kompilieren.

Andersrum gibt es auch die Möglichkeit, bei einem Double, ich nenne den jetzt mal D2 explizit noch dieses D hinten ran zu hängen, das kann ich machen, muss ich aber nicht machen, weil der einfach automatisch schon erkennt, dass es ein Double ist, sobald ich mit einer Kommazahl arbeite. Bei ganzen Zahlen wird immer von dem Int ausgegangen, wir haben uns gerade angeguckt, was passiert, wenn ich versuche, ein Int, der eindeutig größer ist, als der Datentyp, in den ich das reinspeichern will, es zulassen würde, zu verwenden. Ja, also das geht nicht ohne weiteres. Normalerweise gehen wir hier aber von einem Int aus, der irgendwie gespeichert wird. Wenn wir jetzt hier explizit einen Long speichern wollen, wir hatten ja gesagt, ein Long hat, also ein Int hat so minus 2 Milliarden irgendwas, bis 2 Milliarden irgendwas an Werten, also an den Wertebereich, der irgendwie dadurch abgedeckt werden kann. Wenn ich jetzt hier einen Long speichern will, ich nenne den L2, der ganz eindeutig größer ist, als der Int das zulassen würde, sprich, ich muss jetzt hier echt aufpassen, also 5 Milliarden, 1, 2, 3, 1, 2, 3, 1, 2, 3, ja, das ist eine sehr, sehr große Zahl. Und ich würde jetzt hier versuchen, das Ganze zu speichern.

In dem Moment würde es heißen, Fehler, die Ganzzahl ist so groß. Also hier reicht es nicht aus, dass das Programm einfach davon ausgeht, wenn ich diese Zahl nicht irgendwie erkenntlich mache als was anderes, dann ist es erst mal ein Int. Unten int ist es eben einfach zu klein, um diese riesige Zahl, müssten 5 Milliarden sein, wenn ich mich jetzt nicht in den Nullen irgendwie verzählt habe, dazu schämen. hier müsste ich dann ein L anhängen und dieses L sorgt dafür, dass ich die Zahl speichern kann, weil er dann nämlich sagt, Moment, diese 5 Milliarden hier ist ein Long. Jetzt ist es natürlich spannend, wenn man sich mal, wenn man jetzt mal von der anderen Seite drauf guckt, dass ich ohne Probleme hier zum Beispiel, ich nehme jetzt mal die 555, ja, also hier würde jetzt ohne dieses L davon ausgegeben, ausgegangen werden, das ist ein Int und da gibt es keine Probleme, das irgendwie in eine Long-Variable zu speichern und das ist ja irgendwie spannend. Wir hatten letztes Mal gesagt, wir haben eben verschiedene Datentypen für ganze Zahlen und die haben unterschiedliche Wertebereiche und wir müssen auch immer Java strengtipisiert sagen, um welche Werte es sich handelt und jetzt sind wir hier und sagen, okay, wir weisen hier, was ein Int ist, also ein Int literal und das weisen wir einem, einem Long zu. Warum geht das?

Das geht deswegen, weil in Java natürlich oder eigentlich auch schon, wenn man mit dem bloßen Auge drauf guckt, die Werte oder manche Werte, andere Werte beinhalten, das heißt, ich kann jeden Wert, der durch ein Byte dargestellt wird, durch ein Short darstellen, beziehungsweise natürlich jeden Wert, der durch ein Byte dargestellt wird, durch ein Long darstellen und so weiter und so fort. Also das ist diese sogenannte Typ-Teilmengen-Beziehung, die einfach nur aussagt. Ein Datentyp der größer ist als ein anderer hat natürlich die Möglichkeit, einen Wert, der durch einen kleineren Datentypen dargestellt werden kann, ebenfalls darzustellen. Ja, ich kann genauso gut die 128 oder 127 zum Beispiel in einen Int packen oder in einen Long oder eben in einen Short, wenn ich es nicht unbedingt gerade in einen Byte packen. Das ist die Typ-Teilmengen-Beziehung. Genauso kann ich jeden Float darstellen als Double, wenn ich lustig bin.

Ich könnte also auch zum Beispiel sagen, Double D2 ist gleich 1,23f und habe hier keine Probleme, obwohl ja f eigentlich sagt, wir haben hier einen Float. Andersrum geht es natürlich nicht. Zumindest nicht ohne Weiteres, da kommen wir gleich dazu. Davor will ich aber noch eine kleine Sache zeigen, nämlich die alphanomerischen Literale. Klingt erst mal sperriger als es ist.

Hatten wir auch letztes Mal schon gesehen beziehungsweise im allerersten Mal, wo wir auf Code geguckt haben gemeinsam. Hier bei den Zeichen haben wir gesagt, wir müssen diese Single Quotes, diese einfachen Anführungszeichen verwenden. Ja und das macht eben erkenntlich, hier handelt sich es um ein Character. Das heißt, hier weiß Java auch ohne explizit irgendwie noch großartig mehr zu erläutern. Hierbei handelt sich es um ein Character.

Auf der anderen Seite hatten wir eine Sache auch schon kennengelernt, wenn ihr euch erinnert. Und zwar, beim allerersten Mal hatten wir so ein System Out PrintLine Hallo Welt und hatten hier so doppelte Anführungszeichen verwendet. Ich könnte jetzt natürlich auch was Schönes schreiben.

Hallo World meinetwegen. Und auch das hat ohne Probleme geklappt. Ja, das ist der Datentyp String, den wir jetzt bewusst hier oben erst mal weggelassen haben.

Der gehört nämlich eigentlich nicht zu den elementaren Datentypen, ist aber irgendwie so ein bisschen zwischen elementaren und komplexen Datentypen. Da wird es dann ein eigenes Video dazu geben. Aber auch hier handelt sich so mein alphanumerisches Literal mit diesen doppelten Quotes, also Double Quotes, Gänsefüßchen, wie auch immer man es nennen möchte, leiten wir eben eine Zeichenkette ein. Also mehrere Zeichen hintereinander. Okay, eine kleine Sache, die ich jetzt noch zeigen will, ist der Fall, dass wir zum Beispiel genau wissen, wir haben hier aus irgendeinem Grund, was in ein Long gespeichert oder noch besser. Wir haben vielleicht einen Double, das ist vielleicht ein schöneres Beispiel. Ich müsste mich nicht vertippen, dass wir Vorteile haben. Denen wir meinetwegen D2 wieder und der hat den Wert 3.0 vielleicht für den Anfang. Und jetzt habe ich hier einen Int, eine Intvariable i2 und aus irgendeinem Grund muss ich der unbedingt den Wert zuweisen von hier oben. Ja, das geht natürlich nicht, wenn ich hier jetzt einfach hinschreibe D2 und das ganze Speicher und versuche auszuführen.

Fehler. In kompatible Datentypen haben wir so ähnlich auch schon mal gesehen, nicht groß überraschend. Und hier kann ich, hier habe ich die Möglichkeit zu casten. Casten heißt so ein bisschen, was nicht passt, wird passend gemacht.

Das heißt, ich setze mich so ein bisschen über Java hinweg und sage dem Moment mal, dieses D2 kannst du bitte schon als Integer interpretieren. Das ist ein bisschen mit Vorsicht zu genießen, ja, weil das natürlich nicht immer geht. In dem Fall hier kann ich, das sieht man ja eigentlich schon mit einem ersten Blick, okay, das würde funktionieren.

Trotzdem ist es so ein bisschen mit Vorsicht zu genießen, kann ich ja gleich mal zeigen. Aber hier würde ich sagen, bitte behandle dieses Variable D2 als Integer und versuche das als Int zuzuweisen. Jetzt kann ich ja hier mal System Out Print Line hinschreiben mit dem Wert von der Variable D2 und würde eben sehen, okay, ja, das wird jetzt als 3 gespeichert, nicht als 3.0, weil 0.0 heißt ja, es ist irgendwie eine Fließkommazahl, sondern als 3. Das heißt, hier klappt es.

Was hier dann zum Beispiel so ein bisschen tricky ist, ist, wenn ich jetzt zum Beispiel 3.7 sage, ja, und dann mache ich genau den selben Spaß nochmal, führt das Ganze aus, sehe ich eben hier wieder 3. Und das liegt darin, dass beim Casting einfach die Nachkommastellen weggeschnitten werden. Da wird nicht etwa aufgerundet, wie man jetzt vielleicht vermuten könnte, sondern die werden weggeschnitten. Ja, also hier zeigt ich so ein bisschen, das ist so ein bisschen mit Vorsicht zu genießen, geht aber grundsätzlich auch, wenn ich mit zum Beispiel ganz sicher bin, dass ich hier eine Datentyp habe, den ich verwenden kann. Java aber sagt, Moment, hier versuchst du gerade irgendwie zwei Sachen miteinander zu verbinden, die eigentlich nicht gehen. Ja, also zum Beispiel eine Double Variable oder einen Double Wert, einen Int zuzuweisen, das geht halt eigentlich nicht. Okay, in dem Sinne würde ich sagen, haben wir das Wichtigste zu Datentypen gesehen und hören uns im nächsten Video.



Operatoren und Ausdrücke

Willkommen zurück, Grundlagen der Programmierung. Diesmal gucken wir uns an Operatoren und Ausdrücke.

Bislang hatten wir ja ans Datentypen angesehen, haben auch schon irgendwelche Daten in Variablen, quasi, oder haben Variablen bestimmte Daten zugewiesen, so rum. Aber so richtig viel mehr darüber haben wir nicht gemacht. Das heißt, das machen wir jetzt. Wir gucken uns an, was sind Operatoren, was sind Operanten, wie bilden wir Ausdrücke. Hier können wir auch nochmal unterscheiden zwischen arithmetischen und logischen Ausdrücken, wo der genaue Unterschied liegt. Sehen wir sofort.

Im Rahmen dessen vielleicht eine Wiederholung von was, was man im Mathekurs schon kennengelernt hat, ansonsten so ein kleiner Teaser, was zu was, was in Mathe noch deutlich vertieft werden dürfte, und zwar Modulo. Und abschließend gucken wir uns an, in welcher Reihenfolge die Ausdrücke, die wir gebildet haben, überhaupt ausgewertet werden. Ich würde sagen, wir legen direkt los, wir steigen direkt in den Code. Ich habe hier mal ein bisschen aufgeräumt, sodass nur noch diese Main-Methode da ist, und wir hier quasi auf einem neuen Blatt anfangen können. Bis jetzt hatten wir das hier kennengelernt.

Integer A weisen wir einen Wert zu, und Integer B weisen wir auch einen Wert zu. Vielleicht ist das hier eine super Sache. Das ist jetzt aber noch nicht ein Programm, was die Welt riesig weiterbringen wird, würde ich behaupten, weil wir noch nicht so wirklich viel mit diesen Werten machen. Das machen wir jetzt.

Ich greif hier schon mal vorweg und schreibe hierhin. Integer C ist A plus B. Dürfte jetzt nicht, ob es B muss natürlich klein sein, dürfte jetzt nicht sein, was großartig überraschend ist, dass so etwas funktioniert. Ich kann auch hier mal eine Konsole ausgeben, was der Wert vom C dann wäre. Genau, 579, wenig überraschend. Wenn ich A plus B rechne, 123 plus 456, kommt eben die entsprechende Zahl raus.

Okay, super. In dem Moment hier, das ist ja neu für uns, haben wir schon unseren ersten Ausdruck gebildet, um genau zu sein, unseren ersten arithmetischen Ausdruck. Ein arithmetischer Ausdruck ist ein Ausdruck oder eine Rechenvorschrift letzten Endes, wo ein numerischer Wert rauskommt.

Am Ende des Tages nichts anderes als das, was wir seit der Grundschule irgendwie im Matheunterricht machen oder eher gesagt in der Grundschule gemacht haben und dann kann irgendwann Buchstaben dazu. Genau, wenig überraschend auch an der Stelle, dass ich andere Zeichen hier reinsetzen könnte, mal, minus oder auch geteilt. Hier muss man ein bisschen aufpassen, mal so ein Sternchen geteilt ist, so ein Slash anstatt so einen Doppelpunkt, wie man es vielleicht vermuten könnte. Okay, nichts, was hier wirklich überraschend ist und entsprechend kommen natürlich auch andere Werte raus.

Wir kennen das alles, wie gesagt, schon aus der Grundschule, vielleicht kennen wir aber noch nicht die Namen oder das Vokabular dahinter so ganz. Das, was ich hier jetzt geändert habe, ist der sogenannte Operator. Das heißt, das Ding in diesem Ausdruck hier gerade, was sagt, was mit den einzelnen Werten so richtig passieren soll, oder wie die in Verbindung stehen, oder wie auch immer man das jetzt bezeichnen möchte, ist ja ein Unterschied, ob ich hier plus oder minus oder mal oder geteilt reinschreibe. Auf der anderen Seite dieses A bzw.

dieses B, das sind die Operanten, sprich die Dinger, mit denen irgendwas passiert oder die irgendwie verarbeitet, verwertet, wie auch immer wer. Okay, eine neue Sache, die ich hier zeigen kann, vielleicht neu, vielleicht auch schon bekannt aus dem Mathekurs, aber in jedem Fall gar nicht so neu, ist der sogenannte Modulo-Operator. Ich schreibe hier mal was hin. Ich sage int i, meine Dwegen, ist gleich 17 Modulo 5. Und ich kann das auch direkt mal aus der, auf der Konsole, System, PrintLine ausgeben.

Ja, i. Und wir sehen hier, da kommt zwei raus. Okay, komisch. Was ist das? Wie gesagt, vielleicht ist es schon bekannt, ansonsten möchte ich es ganz kurz anschneiden oder wiederholen. In der Grundschule habe ich immer gelernt, wenn wir 17 durch 5 teilen, dann ist das 3 Rest 2. Diese 2 hier ist genau die 2, die hier in dem i abgespeichert wird. Ja, das heißt, der Rest bei Narteilung sozusagen. 17 durch 5 ist quasi, 15 ist durch 5 Teil bei dementsprechend 3, irgendwas. Und anstatt jetzt hier 3, irgendwas hinzuschreiben, sagen wir eben Rest 2. 2 bleiben sozusagen übrig.

Dürfte jetzt nicht ganz, ganz neu sein, vielleicht nur eben ein neuer Name. Und wenn man noch ein bisschen weiter denkt, heißt es, dass bei diesem Ausdruck hier oben, also Modulo 5, irgendwas Modulo 5, nichts anderes rauskommen kann als irgendeine Zahl zwischen 0 und 4. Weil wenn ich zum Beispiel 19 durch 19 Modulo 5 oder 19 durch 5 teilen würde, in der Grundschule würden wir dann sagen, da kommt 3 Rest 4 raus. Ja, das heißt Modulo 19 Modulo 5 wäre 4. Auf der anderen Seite, wenn ich aber 20 Modulo 5 rechne oder erst mal 20 durch 5, dann hätten wir 4 Rest 0.

Weil die 20 eben durch 5 teilen war es, dementsprechend Modulo 0. Okay, soweit so gut. Eine kleine Sache, die ich an der Stelle auch noch direkt zeigen kann, weil es einfach in der Programmierung recht wichtig ist, ist, ich könnte ja jetzt zum Beispiel, ich fahre einfach das hier mal wieder und sage, ich habe den Wert 20, meinetwegen. Ich könnte ja jetzt sagen, i soll einfach i plus 3 sein. Ja, also 23 würde ich herauskommen, muss ich jetzt nicht extra ausführen, ist eine häufige Sache. Und hierfür gibt es eine vereinfachte Schreibweise, was einfach doch eine Sache ist, die man häufiger braucht, nämlich dieses plus gleich 3, i plus gleich 3, ist dasselbe wie i ist gleich i plus 3.

Und ein Fall, den man auch häufig hat, wir werden uns auch noch im Laufe des Semesters ansehen, wo das dann eine entscheidende Rolle spielt, ist, dass wir nicht irgendwie um 3 hoch zählen, sondern um 1. Und hierfür gibt es noch eine kürzere Schreibweise, nämlich i plus plus einfach. Ich kann das auch mal zeigen, ich lösche das hier mal und gebe das auf der Konsole aus. Genau, wenig überraschen sehe ich jetzt hier, 21, super.

Eine spannende Sache hierbei ist, in welcher, ja, wann da hochgezählt wird. Ich könnte ja jetzt auch alternativ einfach sagen, gib mir nicht i aus, sondern gib mir i++ aus. Ja, und in dem Fall, es handelt sich bei diesem plus plus um so einen sogenannten unäheren Operator, das heißt, ein Operator, der einfach an meinen i sozusagen ran gehangen werden kann. Und in dem Moment hier, wo ich i++ ausgebe, sehe ich, okay, da kommt 20 aus. Das liegt daran, dass wir das plus plus an der Stelle nach dem i schreiben, was verstanden wird als Rechne da mal eins dazu, aber erst nachdem das i sozusagen verwertet worden ist, in dem Fall von dem System Outprint Line. Es gibt noch eine andere Sache, nämlich statt i++ plus plus i, was vor der Verarbeitung hochzählt und was dementsprechend hier 21 ausgeben würde. Genauso gibt's minus minus eben sowohl am Anfang, also minus minus i, beziehungsweise i minus minus, beziehungsweise i kann ja jede Variable sein, ja, also einfach ein beliebiger Variable-Name.

Auch das geht. Okay, das war jetzt Mathematik oder mathematische Ausdrücke, ein bisschen, ja, einem neuen Gewand vielleicht, neue Schreibweisen irgendwie in Java statt auf dem Blackpapier, aber nicht viel, was über Grundschulmathematik hinausgeht. Das war die mathematische oder die arithmetischen Ausdrücke. Alternativ kann ich ja auch Ausdrücke haben, die einfach nur sagen stimmt oder stimmt nicht. Also zum Beispiel, wir hatten ja schon kennengelernt, Booleans, Boolean B ist gleich, keine Ahnung, 5 ist größer als 4 und dann würde ich jetzt eben erwarten, wenn ich sage System System, Out, Print, Nein, gebt mir doch mal bitte B aus, dann würde ich doch erwarten, dass hier true steht. Ja, genau.

Super. Okay, ja, ich kann das natürlich auch verbinden. Ich könnte jetzt zum Beispiel sagen, 5 ist größer als 4 mal 4 zum Beispiel. Ich kann ja auch, beliebe ich, irgendwelche Nährzeichen noch reinsetzen. In dem Moment würde ich erwarten, dass false rauskommt, ja, weil 5 nicht größer ist als 4 mal 4, 4 mal 4 ist 16 und 5 ist kleiner als 16. Okay, sehr schön. Das ist ein Part von logischen Ausdrücken auch bis jetzt wenig überraschend.

Wir bauen das aber jetzt noch mal ein bisschen weiter aus und zwar könnten wir ja jetzt sagen, Moment mal, wir wollen vielleicht das mehrere Bedingungen zutreffen. Jetzt zeige ich eine kleine Sache. Zum Beispiel könnten wir sagen, wir haben ein Integer i und das ist meinetwegen wieder die 17 und wir wollen jetzt gucken, ob dieser Integer gerade ist und gleichzeitig größer als, keine Ahnung, 15 meinetwegen. Dann könnte ich sagen, ich schmeiche das mal wieder in den Bullien, den er nicht B oder die Variable nenn ich B, um zu gucken, ob ein Integer gerade ist oder ob eine Zahl gerade ist, kann ich ja sagen, Modulo 2 ist gleich 0. Hier muss man aufpassen, ja, ich habe hier ist gleich, ist gleich geschrieben.

Das liegt daran, dass dieses ist gleich hier, das kennt wir schon aus den vorherigen Videos auch, das ist so dieses ist gleich, was sagt, okay, hier wird irgendein Wert zu gewesen, das ist sozusagen schon reserviert und für dieses vergleichende ist gleich, schreiben wir eben deswegen zwei Gleichheitszeichen. Okay, wenn ich sage i oder irgendeine Zahl, Modulo 2 ist 0 oder darauf prüfe, dann prüfe ich ob die Zahl gerade ist oder nicht, ja, weil eine Zahl, die ungerade ist, ist eben irgendwas, rest 1, während eine gerade Zahl irgendwas, rest 0 ist, wenn ich durch 2 teile. Okay, ich kann sagen, wir hatten gesagt, i ist gerade und ich habe schon wieder vergessen, aber i ist meinetwegen größer als 15 und komme gleich dazu ein bisschen was mehr zu dem Ausdruck zu erzählen. Ich gebe das mal aus, ja, i ist natürlich ungerade, zwar größer als 15, aber ja, ungerade. Dementsprechend kommt hier false raus, ich habe hier dieses doppelte und drin, das ist eine logische Verknüpfung, die einfach sagt, beide Bedingungen müssen wahr sein, ansonsten ist dieser Ausdruck eben falsch und alternativ dazu haben wir auch noch das logische oder, ja, zum Beispiel könnte ich ja sagen, i ist entweder größer als 15 oder ist eine gerade Zahl und in dem Fall hier wäre das bei der 17 true, ja, weil zwar nicht beide Ausdrücke wahr sind, aber wenigstens einer von den beiden, das heißt bei diesem oder hier, bei diesem sozusagen das inklusive oder muss eine der beiden Seiten wahr sein. Alternativ dazu, ja, und vielleicht das hier auch noch mal zu zeigen, zu diesem ist gleich, könnte ich auch sagen, Ausrufe zeichen gleich, das ist sozusagen nicht gleich, das heißt in dem Fall würde er prüfen, ist i ungerade oder ist i größer als 15, in dem Fall treffen sogar beide Bedingungen zu, ja, und das funktioniert. Ein ganz kurzer letzter Abschnitt, auch wenn ich schon wieder die 10 Minutenmarke überschritten habe, ist die Auswertungsreinfolge, es ist, wir versuchen es hier wirklich auswesentliche runter zu brechen, wir lesen nicht ganz von links nach rechts an der Stelle, ja, wir weisen B irgendwas zu, aber das wird natürlich erst mal ausgewertet und die Auswertungsreinfolge ist auch eigentlich ziemlich wenig überraschend, das heißt das ist das, was man irgendwie aus der Grundschulung kennt, Punktvorstrich, ja, wenn ich irgendwie 1 plus 3 mal 5 rechne, dann wird eben dieses 3 mal 5 ausgerechnet vor dem 1 plus, andersrum hier bei diesen logischen Ausdrücken ist es so, dass zum Beispiel dieses i ist größer als 15, ausgewertet wird vor dem oder, hier, ja, es ist eigentlich so, wie man es vielleicht verstehen könnte, ich gucke eben ist i modulo 2 ungleich 0 oder ist i größer als 15 und dementsprechend werden diese beiden Blöcke links und rechts von dem oder zuerst ausgewertet, wenn ich mir aber unsicher bin oder wenn ich vielleicht ein bisschen Leserlichkeit schaffen möchte, kann ich hier Folgendes machen, ich kann einfach Klammern setzen um den Ausdruck rum und bin auf der sicheren Seite, das ist auch wie in der Mathematik, kennt man eigentlich, dass alles, was in Klammern steht, eben bevor zum Ausgewertet wird, insofern auch nichts wirklich neues. Okay, bis dahin und bis zum nächsten Mal.



Ternärer Operator (Ternary Operator)

Hallo zusammen, Grundlagen der Programmierung, das letzte Video von diesem ersten Block. Was wir uns hier angucken wollen, was auch relativ kurz und schnell gehen sollte, ist der Ternäre-Operator bzw. auf Englisch Turnery Operator.

Wir gucken uns an, was es damit auf sich hat bzw. wie wir damit basierend auf irgendeiner Kondition oder einer Bedingung Werte zuweisen können. Ich würde sagen, wir legen direkt los. Ich habe hier wieder wunderbar aufgeräumt. Die Main-Methode.

Super. Ich zeige das erst mal an einem kleinen Beispiel, was vielleicht noch nicht ganz so komplex ist. Danach habe ich ein zweites Beispiel dabei, was auch ganz gut wiederholt, was wir bei den logischen Ausdrücken im letzten Video gemacht haben oder ein bisschen darauf aufbaut. Erst mal mein kleines Beispiel.

Wir kennen das schon. Ich habe meine Drehgene Variable A, die hat den Wert 123 und eine Variable B, die hat den Wert 456 bzw. 123 und 456.

Zwei Ganzzahlenwerte, zwei Integer. Jetzt könnte ich zum Beispiel sagen, ich möchte rausfinden, was der maximale Wert von den beiden ist und möchte den eine Variable zuweisen. Der Ternäre-Operator macht nichts anderes als eine Bedingung zu nehmen. Wenn diese Bedingung erfüllt ist, dann wird ein Wert A zu berücksichtigen bzw. wenn diese Bedingung nicht erfüllt ist, dann wird ein Wert B. Das weiß irgendwie blöd formuliert, weil die Variable genauso heißen. Das hat damit natürlich nicht unbedingt was zu tun.

Ich könnte jetzt zum Beispiel sagen, ich meine eine Int, den ich meine wegen Max nenne, ich möchte dem zuweisen, was ist die größere Zahl von den beiden. Und dann könnte ich jetzt sagen, wenn A kleiner ist als B, dann, also das ist erstmal unsere Bedingung hier, und dann setze ich so ein Fragezeichen und nach diesem Fragezeichen den ersten Wert, der dann genommen werden soll. Vielleicht noch mal hier das kleine Wiederholung. Das hier würde natürlich noch nicht funktionieren, weil wir hier einen Boolean haben, aber die Variable vom Datentyp Integer ist.

Also fehlt dann auch was. Nach dieser Bedingung setze ich den Wert, der falls dieser Part hier wahr ist, also falls hier true rauskommt, dann möchte ich bitte B nehmen, also wenn B größer ist als A oder A kleiner ist als B, so rum, dann soll doch bitte B diesem Wert Max hier zugewiesen werden. Und ansonsten, das trenne ich dann ab durch so einen Doppelpunkt, bitte der Wert von A. Wenn ich das jetzt auf der Konsole ausgebe, System Out, Print Line, Max, also der Wert von Max, dann würde ich jetzt hier erwartungsgemäß die 456 sehen, weil dieser Ausdruck hier ist false, dieser Ausdruck, Entschuldigung, dieser Ausdruck hier ist true, A ist kleiner als B und dementsprechend nehmen wir hier diesen allerersten Wert. Okay, schöne Sache. Ich zeige nochmal was anderes und zwar baut es wie gesagt so ein bisschen auf den logischen Ausdrücken auf, ist eine ganz schöne Sache, die wir mittlerweile schon uns bauen können. Und zwar, ich sage, wir haben hier ein Integer Ja und dieses Jahr ist 2024 und wir wollen jetzt einfach rausfinden, ob es sich um ein Schaltjahr handelt oder nicht. Ich speichere das mal in den Bullien ab, ist Libye und ein Schaltjahr heißt ja, dass das Jahr durch vier Teilbar ist, das heißt, ja Modulo 4 ist gleich null, also wenn ich durch vier Teile möchte, dass da kein Rest rauskommt. Und außerdem, damit das ein Schaltjahr ist, muss das Jahr nicht, ich setze hier schon mal klammern in Weißer Voraussicht, nicht durch 100 Teilbar sein, sprich Modulo 100 darf nicht null sein. Es sei denn, das Jahr ist durch 400 Teilbar, das heißt, wir können hier mit so einem oder sagen, außer sozusagen, das Jahr ist durch 400 Teilbar, das heißt, Modulo 400 gleich null.

Okay, ich kann hier mal so ein System Outprint Line setzen und dann einfach diese Variable beziehungsweise den Wert ausgeben lassen. Und dürfte jetzt hier sagen, ja also 2024 ist ein Schaltjahr, Gegenprobe 2023, auch, sorry, kein Schaltjahr natürlich, ungerade sowieso nicht, Gegenprobe vielleicht das Jahr 2100, das ist zwar gerade, dürfte aber trotzdem kein Schaltjahr sein, weil es eben nicht durch 400 Teilbar ist. Der ist zwar auch durch 100 Teilbar so rum, ist aber gleichzeitig auch durch 400 Teilbar und deswegen ein Schaltjahr, kein Schaltjahr, ups, ja 200, selber verwirrt, so okay true.

So, okay, sehr schön. Hier würde ich jetzt auch nochmal kurz den Ternary-Operator verwenden, um eine Sache, die wir auch schon mal in der im allerersten Video gesehen haben, gleich zu nutzen. Ich muss nicht zwangsläufig mithilfe des Ternary-Operators irgendwelche Werte zuweisen, also den Ternary-Operator zu nutzen, um so wie am Anfang zum Beispiel zu sagen, bitte gib mir die größere von den beiden Zahlen. Ich kann das auch direkt zum Beispiel hier in so einem System Outprint Line verwenden.

Wir hatten ja Strings oder Zeichenketten werden nochmal detaillierter behandelt in dem folgenden Video, aber fürs Erste hatten wir das ja auch schon mal verwendet, ja wir wissen, wenn wir mit so Gänsefüßchen, mit so doppelten Anführungszeichen, üben mit Zeichenkette einleiten, dann wird es automatisch verstanden, als ein Zeichenkette. Das hatten wir ganz am Anfang mit diesem Hallo-Welt. Und jetzt könnten wir hier zum Beispiel statt true oder false einfach ausgeben, Schaltjahr oder eben Alternativ. Also wenn dieser Bedingung true ist, dann soll bitte Schaltjahr ausgegeben werden, aber ansonsten bitte kein Schaltjahr, ja ich führ das mal aus. Und statt true haben wir jetzt hier eben entsprechend Schaltjahr stehen. Wenn ich jetzt irgendwas nehme, was garantiert kein Schaltjahr war, 2023 hatten wir vorhin, wird hier kein Schaltjahr ausgegeben. Ja also auch hier nutzen wir diesen Turnery Operator, der einfach nur sagt, wenn diese Bedingung hier true ist, dann bitte Schaltjahr in dem Fall ausgeben und wenn diese Bedingung hier nicht true ist, dann bitte kein Schaltjahr.

Ich habe das jetzt hier auch ausgelagert, ich habe jetzt hier eine extra Variable angelegt für dieses ist-lieb hier, wenn ich jetzt möchte, das ist jetzt aber natürlich dann ein ziemlich langer Ausdruck, könnte ich das auch direkt statt dieser Variable hier reinsetzen und das alles ist ja eine Bedingung, ist ja ein Bullion. Okay, ja also ich könnte jetzt hier streng genommen löschen oder erst mal so auskommentieren, es würde auch funktionieren, wenn ich das alles hier unten reinschreiben würde, ist aber vielleicht nicht mehr so sauber und nicht mehr so lesbar, deswegen würde ich davon eher abraten. Okay, eine kleine Sache zum Abschluss nochmal, die man manchmal sieht und von der ich irgendwie abraten würde, es ist jetzt auch nicht unbedingt schlimm, wenn man das macht, aber es ist eigentlich sinnlos. Viele Leute gerade am Anfang machen Folgendes, die sagen, Bullion ist lieb hier zum Beispiel, ich habe es so sehr zu löschen, ist nicht so schlau, und sagen, wenn diese Bedingung hier true ist, dann möchte ich bitte mein Bullion hier den Wert true zuweisen und ansonsten den Wert false.

Ja, das funktioniert wunderbar, das kann ich alles machen, das wird auch funktionieren, ich kann das hier auch ausführen, alles völlig völlig erlaubt, völlig gültiger Java Code, muss man aber an der Stelle nicht machen, also ich kann hier natürlich bzw. hier, das ist ja schon ein Bullion, das ist ja schon einen Ausdruck in sich und dementsprechend muss ich hier dann nicht mehr true oder false zuweisen. Das ist also nur ein Hinweis, weil man das manchmal sieht, dieser Turnery Operator ist natürlich super sinnvoll, aber sobald ich natürlich einen Bullion zuweisen möchte, da brauche ich den nicht. Also hier kann man das getrost weglassen an der Stelle. Können wir uns auch nochmal in der Vorlesung oder beim Live Coding dann ein bisschen näher ansehen, fürs erste würde ich es aber dabei belassen. Bis dann.



Grundlagen der Programmierung - Strings (Teil I)



Grundlagen der Programmierung - System.in und Scanner

Heute beschäftigen wir uns mit den Themen SystemIn und dem Scanner in Java.

Motivation für dieses Video ist die Frage, wie können wir Informationen über die Benutzeingabe auf der Konsole einlesen, also dass der Benutzer etwas eingeben kann und diese Information dann in einem Java-Programm weiterverarbeiten. Wir kennen bereits das System Out. System Out Print Line haben wir schon kennengelernt oder Print, mit dem ich Strings oder was auch immer auf der Konsole ausgeben kann. Mit Hilfe von SystemIn können wir Input, also Eingaben, typischerweise von der Konsole für unsere Programme einlesen.

Das heißt, wir können es natürlich auch kombinieren, können sagen mit System Out, lieber Benutzer schreibt nochmal zum Beispiel dein Name auf die Konsole und das, was er dahingeschrieben hat, das können wir einlesen und diese Informationen weiterverarbeiten. Zum Lesen kann in Java die sogenannte Scanner Klasse genutzt werden, mit Hilfe derer elementare Datentypen und Strings eingelesen werden können, also die Werte natürlich. Hier sehen wir mal ein Beispiel-Programm, wie der Scanner genutzt werden kann und wie SystemIn genutzt werden kann. Grundsätzlich werden wir jetzt mal Schritt für Schritt durch dieses Programm durchgehen. Was das Programm macht, also jetzt erstmal ganz grob, ist es fordert den Benutzer auf, einen Namen einzugeben.

Der Name wird danach auf der Konsole ausgegeben in einem Satz und danach fordert das Programm den Benutzer auf, sein Alter einzugeben und dieses Alter wird dann auf der Konsole ausgegeben. Und jetzt gucken wir uns jetzt mal Schritt für Schritt an. Der erste Schritt ist, um den Scanner nutzen zu können, müssen wir die Klasse aus dem Paket JavaUtil importieren. Das machen wir hier oben vor der Klassendefinition tatsächlich schon mit einem Import java.util .scanner. Wenn wir später mehr oder später in der Veranstaltung, während wir auch weitere Klassen importieren, das haben wir jetzt am Anfang nicht so, das heißt diesen Teil, den kann man sich mal gut merken, wenn man mit einem Scanner arbeiten möchte. Was wir auch noch machen müssen, ist mit einem neuen Scanner-Objekt zu erstellen. Was jetzt hier noch aufgekraut ist, ist tatsächlich hier diese Klassendefinition.

Hier öffnet sich hier, schließt hier und dann die Main-Methode öffnet sich hier und schließt hier. Und der erste Schritt, den wir hier machen, um eben jetzt mit dem Scanner arbeiten zu können, ist ein neues Scanner-Objekt zu erstellen, also das ist der Datentyp, großgeschrieben. Dann der Name der Variablen, hier nennen wir sie einfach hier Scanner, wir können sie auch Scanner 1, 2 oder 3 nennen. Und jetzt kommt hier so ein Schlüsselwort, das wie gesagt sollte man sich auch am Anfang merken, später werden sie das sehr viel öfters benutzen. New Scanner und dann kommt hier dieser Befehl hin SystemIn, das heißt ich habe jetzt einen Scanner auf der Konsole sitzen.

Die Textausgabe ist ja bereits bekannt mit SystemOutprint, ohne Zeilenumbruch oder SystemOutprintLine mit Zeilenumbruch. Und was wir jetzt hier zum Beispiel in diesem Schritt machen ist, dass wir auf der Konsole eingeben, gib mal also Enter your Name, Doppelpunkt und dann ist da im Platz, dass der Benutzer sein Namen eingeben kann. Genau und diesen Namen werden wir später ausgeben. Hier unten ist gleich noch mal für das Alter.

So und jetzt brauchen wir aber noch diesen Zwischenschritt, indem wir quasi das, was auf der Konsole steht, einlesen und weiter verarbeiten. Das machen wir mit Hilfe des Scanners und einer Methode auf diesem Scanner. Was wir hier benutzen ist die sogenannte Methode NextLine und was die Methode macht ist, dass sie die ganze Textzeile als String einlässt. Also alles, was jetzt auf der Textzeile kommt, wird eingelesen vom Scanner und in der variablen Name gespeichert.

Und damit ich das jetzt überprüfen kann, kann ich danach mal wieder ein SystemOutprintLine machen und kann einfach mal diesen ganzen String hier auf der Konsole ausgeben lassen. Das oder etwas Ähnliches passiert hier unten beim Alter, int age. Hier nutzen wir den Scannerpunkt NextInt und die Methode NextInt, die ermöglicht, dass ich die nächsten int lesen kann. Das heißt, es muss auch wirklich eine int Zahl sein, also eine ganze Zahl. Das Ganze wird dann in der Variable age gespeichert und im nächsten Schritt tatsächlich dann auch schon wieder auf der Konsole ausgegeben. Das war es dann eigentlich schon, damit ist das Programm komplett. Das ist jetzt nur ein Beispiel.

Wenn ich jetzt mit Scanner arbeite und System in arbeite, dann gibt es hier unten noch weitere Methoden wie zum Beispiel Next Boolean, Next Short oder überhaupt Next. Wichtig ist vielleicht noch, das habe ich jetzt gerade übersprungen, wenn ich unzulässige Werte eingebe, dann treten sogenannte Fehler auf, also Exceptions. Die können wir behandeln. Das heißt, wenn ein Fehler auf Drittes stürzt, ist das Programm ab. Das können wir aber behandeln, lernen wir aber erst später im Semester. So, und jetzt schauen wir uns das Ganze mal praktisch an. So, ich habe jetzt wieder ein VPL vorbereitet. Hier oben habe ich mal wieder unser Ziel übernommen.

Wie können wir Informationen über die Benutzeingabe auf der Konsole einlesen und weiterverarbeiten? Unsere klassische Klasse hier heißt immer noch Hello und eine Main Datei haben wir auch. So, wir erinnern uns, ersten Schritt den wir machen müssen, ist, dass wir den Scanner importieren müssen. Das heißt, wir schreiben hier als Allererstes vor der Klasse noch import java.util .scanner. Vergessen das Semi-Color nicht und haben damit den Scanner, also die Klasse, importiert und können sie jetzt in den nächsten Schritten nutzen. So, zweite Schritt den wir machen mussten war, wir legen uns ein neues Scanner-Objekt an. Das heißt, wir beschreiben den Datentyp, es ist ein Scanner. Wir nennen ihn jetzt mal ein bisschen anders, damit man es einfach auseinander halten kann.

Ich nenne ihn jetzt einfach mal SC1 und sage, das ist ein neuer Scanner und hier müssen wir quasi SystemIn nutzen, damit wir etwas von der Konsole lesen können. So, wenn wir das Ganze jetzt ausführen würden, würde noch nichts passieren. Ich kann es gerne mal zeigen. Hier passiert jetzt noch nichts.

Das, was wir jetzt machen müssen, ist, wir müssen etwas auf die Konsole schreiben, damit unser Benutzer weiß, dass er etwas zu tun hat. Also zum Beispiel SystemOut, Print. Hallo, schreibe ich jetzt mal, wie geht es dir? Wie geht es dir? Wäre eine Möglichkeit.

So, das kennen wir ja bisher, das ist jetzt eine ganz normale Konsolenausgabe, das heißt, es steht hier einfach auf der Konsole und jetzt passiert hier erst mal nichts mehr. So, was machen wir als nächstes? Jetzt wollen wir ja etwas vom Benutzer einlesen, das heißt, wir müssen unseren Scanner benutzen und das, was der Scanner liest, soll ja in eine Variable gespeichert werden. Und das ist ein String. Die Variable heißt jetzt einfach mal befinden, nenne ich sie einfach mal und sage, das ist Scanner.nextline. So, das heißt, der Scanner liest die nächste Linie und speichert das ganze String befinden.

Jetzt können wir einfach mal ausprobieren, wie sieht es aus? Oh, hier habe ich ein Fehler gemacht, das hat nicht kompelliert, schauen wir mal, was habe ich denn getan? Oh ja, jetzt habe ich natürlich Scanner geschrieben, den Variablenamen gibt es gar nicht. Tatsächlich heißt mein Ding ja hier SC1. Es ist gut, dass ich das mal unbenannt habe, damit man das einfach mal sieht.

Also wichtig ist, dass hier der Name gleich dem Namen ist. So, ich füße aus und sehe, hallo, wie geht es dir? Jetzt kann ich zum Beispiel einsagen, mir geht es gut. So, jetzt passiert hier nichts mehr. Die Konsole schließt auch nicht, weil der Scanner ist tatsächlich noch offen und ja, hier erwartet jetzt darauf, dass ich damit irgendwas mache.

So, und das können wir jetzt auch tun, indem ich diese Variable nehme und die mal auf der Konsole ausgebe mit einem System Outprint Line und dann würde ich einfach mal schreiben, du hast gesagt, doppelpunkt und ich möchte gerne das aufnehmen, was du eben auf der Konsole eingegeben hast, als das befinden. Ich speichere das ganze, gebe es auf, hallo, wie geht es dir? Auch ganz gut, enter, du hast gesagt, auch ganz gut. So, und hier so kann man rein theoretisch, nicht wirklich eine Unterhaltung führen, aber so kann man immer hingehen und sagen, ich schaue mir hier an, was, ja, ich lese etwas über die Konsole ein, ja, über den Scanner beispielsweise mit dem Next Line oder über und kann das dann entsprechend wieder ausgeben. Jetzt hatten wir noch ein Beispiel, das nehme ich kurz auch nochmal auf mit dem Int, da war nämlich die Abfrage, wie alt bist du beispielsweise, wie alt bist du, könnte ich mal fragen und das ganze speichere ich in String, nee, ich wollte das gerne in einem Int speichern, Int, Alter, gleich Sc1 Punkt, Next Int so und das ganze möchte ich dann gerne auf der Konsole noch ausgeben, Print Line, du bist manchmal plus Alter plus Jahre alt. Habe ich jetzt so zusammengesetzt, dass ich hier zwei Pluses habe, also ich habe du bist und hier wird das Alter dann eingesetzt, Jahre alt, das ganze gebe ich auf der Konsole aus, führen wir jetzt mal aus zusammen, hallo, wie geht es dir, passt, du hast gesagt, passt, wie alt bist du, nehm ich mal hier 13, du bist 13 Jahre alt und das war es auch schon zum Thema Scanner und System in String.