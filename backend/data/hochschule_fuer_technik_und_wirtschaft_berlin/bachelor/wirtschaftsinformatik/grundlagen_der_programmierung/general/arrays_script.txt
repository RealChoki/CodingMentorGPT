Array Intro

Willkommen zurück. Heute beschäftigen wir uns mit dem Thema Arrays. Motivation für das Video ist, erstens, was ist ein Array und wie verbrauchen wir ihn? Zweitens, wie wird ein Array deklariert? Und drittens, wie wird ein Array erzeugt?

Was ist ein Array? Bis dato haben wir Datentypen kennengelernt, die, wenn ich eine Variable anlege, immer nur genau ein Wert speichern können. Also zum Beispiel ein Int kann genau eine ganze Zahl speichern, ein Bullien kann genau einen bulischen Wert speichern. Ein Array ist jetzt ein Datentyp, der es mir möglich, mehrere Werte des selben Datentyps zusammenzufassen und die auch in einer Reihenfolge zusammenzufassen. Also zum Beispiel ein IntArray, ein DoubleArray oder ein BullienArray. Und in diesem Array können dann eben auch nur Werte dieses, also des einen Datentyps drin sein. Ich könnte jetzt keinen Array haben, der Ints und Double Symboliens gemischt hat, sondern der hat entweder nur Entwerte oder nur Double Werte oder nur bulische Werte. Darüber hinaus können auch Strings, also ich kann Array mit Strings haben oder ich kann auch ein Array mit sonstigen Objekten haben. Das lernen wir mit der Objektorientierung. Wichtig ist, die Länge von dem Array wird einmal festgelegt bei der Erzeugung und ist danach unveränderlich.

So, wie kann ich mir sowas vorstellen? Hier unten ist mal ein Array aufgezeichnet, das ist jetzt wirklich nur für meine eigene Visualisierung, der im Rechner ist jetzt nicht wirklich eine Visualisierung hinterlegt, das ist nur für mich. Aber ich kann es mir jetzt vorstellen, das wäre jetzt ein Array der Länge 6 mit eben 6 Fächern und wenn das jetzt ein Int-Array wäre, dann wären die Werte Werte 1 bis Werte 6 alles ganz zu zahlen. Eine andere Visualisierung wäre hier, also alles wo ich jetzt gleiche Compartments habe, die aneinander gereiht sind, könnte für mich eine Visualisierung von einem Array sein. Wie deklariere ich denn jetzt ein Array? Ein Array wird deklariert, indem ich den Datentyp angebe, zum Beispiel ein Int und eckige Klammern dahinter setze. Das wären Int-Array, das ist ein String-Array. Natürlich habe ich auch hier, wenn ich damit arbeiten möchte, dass ich einen Namen angeben muss, also einen Variablenamen und hier habe ich jetzt zum Beispiel eine Variable und die ist vom Typ charArray, also die hat ein Array mit Characters drin.

Hier haben wir ein Array primes, das ist ein Int-Array und hier unten, das kommt uns ganz bekannt vor, die Arx, das ist ein String-Array. Kennen wir aus der Main-Methode. Nachdem ich den Erre erzeugt habe, muss ich ihn, nein, wird entschuldigung, nachdem ich den Erre deklariert habe, möchte ich ihn natürlich auch erzeugen. Vorher sehe ich ja nur, hier kommt ein Erre und es ist ein End-Area. Ich weiß aber noch nicht, wie lang dieser Erre ist. So, das ganze passiert, indem ich, also die Erzeugung, indem ich das Schlüsselwort New benutze und angebe, noch mal den Datentyp angebe und die Länge des Erres angebe.

Hier, wir erinnern uns von eben, wir haben diesen End-Area-Primes bereits deklariert und sagen jetzt der End-Area-Primes, der ist quasi neuer Erre, neuer End-Area der Länge 4. Und hier unten haben wir das noch mal inklusive Deklaration, hier habe ich einen Bulschen-Area, also der heißt B-Values und jetzt sage ich, wir können jetzt einen neuer Erre mit 10 Werten. Und wenn ich mir das Ganze jetzt noch mal visualisiere, dann könnte das wie folgt aussehen. Gut, das schauen wir uns jetzt mal praktisch an. Ich habe dafür schon mal etwas vorbereitet, hier oben unsere Klasse Demo und auch wieder eine Main-Methode. Hier, das, was wir eben gelernt haben, hier übergeben wir tatsächlich ein String-Area mit dem Namen ARCs. Interessiert uns jetzt aber gerade nicht, was wir jetzt machen wollen, ist einfach mal ein Erre einlegen.

Wie sieht das aus? Jetzt um das Beispiel von eben nochmal zu nehmen, wenn wir ein End-Area anlegen und der soll Primes heißen, dann mache ich das eben wie folgt, ich gebe den Datentyp an, ich setze die eckigen Klammern dahinter, ich sage, wie soll der Erre heißen und dann sage ich, das ist ein neuer Erre, man sieht es auch durch das Sintax-Highlighting, hier, dass das ein Schlüsselwort ist und ich sage es ein End-Area der Länge 10. So, ich kann das ganze zum Beispiel auch splitten, ich sage, ich mache ein Float-Area, float-eckige Klammern, dass man weiß, das ist ein Array, der Float-Area heißt Texas und ich möchte jetzt erst die Deklaration machen und nach der Deklaration mache ich die Erzeugung und sage, das ist ein neuer Float-Area der Länge 20. So, das war es auch schon mit den Errays, eine Sache, die vielleicht noch sehr interessant ist, das ist jetzt, sind jetzt, oder ein Errays ein Referenzdatentyp, das heißt, ich kann ihn nicht einfach so auf der Konsole ausgeben lassen. Wenn ich jetzt zum Beispiel ein System Outprint Line mache und sage, ich möchte jetzt zum Beispiel diesen Erray Primes anschauen und das ganze mal ausführe, dann bekomme ich nur so eine ID auf der Konsole angezeigt. Die ID sagt mir, das ist quasi die ID von diesem Objekt, von diesem Referenzdatentypen und die Werte kann ich mir jetzt so nicht anzeigen lassen, aber wie wir das machen, weil wir wollen natürlich auch die Werte anschauen, die in so einem Array drin stehen, das lernen wir in einem späteren Video.



Arrays: Lesen und Schreiben

Willkommen zurück. Heute beschäftigen wir uns mit dem Thema Errays, Lesen und Schreiben von Werten. Die Motivation für heute ist, wie können Werte in einem Erray geschrieben werden und weitens, wie können Werte aus einem Erray gelesen werden. Kurze Recap, Deklaration und Erzeugung. Was wir uns im letzten Video angeschaut haben, ist, wie man einen Erray zum einen deklariert, also sagt, hier kommt ein Erray, das ist dieser Teil hier und dann, wie ich einen Erray erzeuge, indem ich das Schlüssel wollt, neu benutze, nochmal den Datentyp angebe und sage, wie viele Plätze wird dieses Erray-Plätze in Anführszeichen zählen, wie auch immer man das nennen möchte, soll oder wird der Erray haben. Hier sind es jetzt vier Stück und genau, damit habe ich einen neuen Erray erzeugt. Was ich noch nicht gemacht habe, ist, Werte in diesen Erray geschrieben.

Wie kann ich das machen? Zum einen ist es wichtig zu wissen, wie spezifische, also im Kontext von Errays, wie ich auf diesen Erray zugreifen kann. Dazu ist es wichtig zu unterscheiden, dass wir zum einen Element haben, das sind die, die hier drin stehen, die bisher noch nicht bekannt sind, also auch noch nicht festgelegt sind und dann der sogenannte Index. Der Index gibt die Position des Errays an und wichtig hier ist, dass wir immer bei 0 anfangen zu zählen. Also wir haben das 0te Fach, das erste Fach, das zweite Fach, das dritte Fach. Da sollten Sie sich auch direkt daran gewöhnen, dass Sie nicht sagen, das erste Fach hat die Nummer 0, sondern wir sagen das 0te Fach und so weiter und so fort. Das ist in der Informatik relativ typisch, dass wir mit 0 anfangen zu zählen.

Wie kriege ich jetzt Werte in diesen Erray rein? Eine Möglichkeit, das hatte ich schon mal zuvor angesprochen, ist, indem ich direkt Initialwerte zuweise, das kann ich machen, indem ich hier in geschleiften Klammern bei der Deklaration Werte angebe, die durch Komma-Tage trennt sind. Sie sehen jetzt hier, dass wir gar nicht explizit angeben, wie lang der Erray ist, aber dadurch, dass ich hier vier Elemente habe, die korrekt durch Komma-Tage trennt sind, weiß der Computer oder der Rechnung, gut, das wird ein Erray des Datentyp INS mit vier Plätzen. Wenn es jetzt beispielsweise ein Boolean Erray wäre, dann müssten jetzt hier Werte stehen wie True, False, False, True, True und so weiter und so fort. Und je nachdem, wie viele Werte ich hier stehen habe, so lang ist auch mein Erray. Wie kann ich nun auf die Erray-Elemente zugreifen? Ich kann darauf zugreifen auf einen Erray-Element, indem ich den Variablennamen nenne und auf den Index zugreife. Den Index gebe ich in eckigen Klammern an.

Das sieht dann wie folgt aus, zum Beispiel, das war ja hier unser Erray Primes, wenn ich auf Primes 3 zugreife, dann greife ich auf hier dieses Fach zu und da steht jetzt die Zahl 7 drin. Also kann ich jetzt diesen Wert beispielsweise eine Variable speichern. Den habe ich jetzt gelesen. Genauso ist das gleich, wenn ich Primes 0 aufrufe, dann kann ich diesen Wert hier rausziehen. Hier unten ist mal ein Beispiel, was ich jetzt mit den Werten machen kann, wenn ich sie lese. Ich weiß ja, dass ich ein INS-Aray habe.

Das heißt, wenn ich eine Zelle lese aus dem Erray, dann wird da ein INS drin stehen und entsprechend kann ich das in einer INS-Variable speichern. Hier unten ist dieses Beispiel. Ich sage INS A ist gleich Primes 3. Also hier dieses Element wird jetzt in A gespeichert.

Primes 0 wird in B gespeichert und genauso kann ich das auch auf der Konsole ausgeben, indem ich sage Primes an der Stelle 1 und Primes an der Stelle 2. Das die hole ich mir jetzt raus. Die Werte, was dann passiert ist, dass das zusammengerechnet wird, eben 3 plus 5 sind dann gleich 8 und auf der Konsole würde jetzt der Wert 8 stehen. Das war jetzt was zum Lesen der Area Elemente.

Natürlich kann ich Area Elemente auch schreiben und das mache ich genauso, indem ich sage an der Stelle, also ich nenne wieder den Variablennamen, nämlich mein Array-Namen Primes und sage an der Stelle 3, schreibe den Wert 1 und an der Stelle 0 schreibe den Wert 42. Wenn ich das mache, jetzt habe ich das jetzt in ihr Schrittweise aufgezählt. Also hier dieser erste Teilne, damit würde ich quasi die 7 streichen und den Wert 1 reinschreiben.

Mit dem zweiten Teil würde ich die 2 streichen und die 42 reinstreiben. Und Sie sehen auch ganz genau, gerade wenn wir uns mit den Indizes benutzen, es ist ganz wichtig, dass Sie wirklich darauf eingehen, dass Nulltefach das erste Fach, sagen Sie hier nicht das dritte Fach, weil das ist ja tatsächlich, also besser gesagt, sagen Sie hier tatsächlich das dritte Fach, wenn Sie aber durchzählen und Sie fangen mit 1 an zu zählen, wer ist eigentlich das vierte Fach. Also nutzen Sie wirklich diese Zählweise von 0, damit Sie da nicht durcheinander kommen.

kommen. Hier nochmal so ein Vergleich, Initialisierung und Wertzuweisung, wie man es noch machen kann, nachdem wir gelernt haben, wie wir Werte in Airbase schreiben. Ich kann entweder so eine implizite Initialisierung machen, indem ich sage in primes, ich gebe implizit die Länge an, nämlich 4 und gebe in diesen geschweiften Klammern an, okay hier sind diese vier Werte, anstelle 0 steht das, anstelle 1 das, anstelle 2 das, anstelle 3 das.

Oder was ich auch machen kann, ich kann ganz normal den area anlegen in primes mit new int, der kriegt vier Stellen und dann gehe ich hin und schreibe in jede Zelle den Wert rein, an der Stelle 0, die wird in Wert 2, 1, 3, 2, 5, 3, 7 und damit habe ich auch den area erstellt, wie ich, genau wie hier oben, das hier ist jetzt zum Beispiel die Kurzschreibweise. So jetzt kommt eine kleine Übung, ich würde Ihnen empfehlen, dass Sie das Video hier mal stoppen und sich einfach mal anschauen mit diesen Anweisungen, wie verändert sich der area über die Zeit. Die Auflösung kommt dann auf der nächsten Folie.

Gut, ich hoffe Sie sind gut durchgekommen durch die Übung. Wie sieht das Ganze jetzt aus? Also wenn wir jetzt diesen initialen area haben, den haben wir angelegt, Samnambas und in der ersten Zeile was passiert ist, dass wir an stelle 1 den Wert 0 schreiben. Das ist genau das, was wir hier machen über den Schreiben den Wert, so sieht unser neuer area aus. Dann gehen wir hin und lesen aus der Stelle 3 den Wert und schreiben den in double D rein. Also Stelle 3 ist die 23 und unser Wert D, unsere Variable D hat jetzt Wert 23. Dann gehen wir hin und schreiben an stelle 0 den Wert D rein, dass das wir eben gelesen haben, das ist ja unsere 23, das heißt sie wird jetzt hier vorne reingeschrieben, überschreibt den Wert. An stelle 2 schreiben wir Samnambas 1, an Samnambas 1 steht hier im Moment der Wert 0 und deswegen gehen wir hin und schreiben diesen Wert an stelle 2. Und dann passiert ja eigentlich nichts mehr, nur noch dass wir was lesen. Wir geben auf der Konsole aus, Samnambas 2, also hier an dieser Stelle 0, 1, 2 lesen wir den Wert und dann wird das 0,0 auf der Konsole stehen. Dazu gibt es jetzt eine kleine Demo. So ich habe natürlich wieder was vorbereitet, unsere Klasse und unsere Main Methode und wir legen uns heute mal ein String Area an und der heißt Bücher oder Favorite Books nenne ich den einfach mal und hier gebe ich einfach mal drei Bücher an die ich total gerne mag. Das sind jetzt einfach fiktive Namen, heißt Broken, How to, was habe ich denn mal hier, How to Sleep Well so und was ist das dritte?

Johnny has a happy life. Jetzt habe ich quasi hier einen Area angelegt mit implizit drei Fächern und genau und das ist ein String Area. So und jetzt kann ich mit diesem String Area arbeiten. Ich kann zum Beispiel sagen, auch ich möchte mir das mal ausgeben lassen. Ich möchte jetzt mal wissen, was steht hier zum Beispiel an der Stelle 0 von Faith Books an der Stelle 0. Das kann ich mir mal ausgeben lassen und würde dann erwarten, dass dann Broken auf der Konsole steht. Schauen wir uns das mal an, was passiert. Genau, hier steht jetzt Broken drauf. Das kann ich natürlich mit allen drei Elementen machen, wenn ich das jetzt einfach mal kopiere. So beispielsweise, was ich an 1 und 1,2, dann müssten mir diese drei Sachen auf der Konsole angezeigt werden.

Genau. So, jetzt könnte ich zum Beispiel hingehen und könnte das irgendwie überschreiben. Jetzt sage ich mal, an Stelle 1 möchte ich tatsächlich was anderes reinschreiben, weil das Buch mag ich nicht mehr. Also würde ich hingehen und sagen Faith Books an der Stelle 1. Das Buch habe ich hier, How to Sleep Well, das mag ich nicht mehr. Das habe ich jetzt super gelernt. Das möchte ich umbenennen und möchte sagen, da soll neuer Stringereien geschrieben werden.

Best Breakfast Dishes. So, das ist mein neues Lieblingsbuch. Das steht jetzt hier mit drin. So, und jetzt kann ich mir das angucken. Das schreibe ich an die Stelle 1 und kann mir das einfach mal ausgeben lassen. Ich zeig das jetzt mal, mach das mal hier vor, damit man mal beide Sachen sieht, also wie ich es alt aussah.

Also zuerst wird der alte Titel ausgegeben und dann sollte der neue Titel ausgegeben werden. So, das kann ich jetzt hier mal machen. Oh, jetzt habe ich ein Fehler da drin. Das kompiliert nicht. Hier fehlt noch ein Semicolon. Ja, natürlich. Vielen Dank. Immer schön die Fehlermeldung lesen, das Ganze nochmal ausführen. Genau. Und jetzt habe ich hier, sieht man, das war meine alte, mein altes Lieblingsbuch an der Stelle 1 und das ist jetzt mein neues Lieblingsbuch an der Stelle 1. Und so kann ich schön mit meinen Arrays arbeiten.



Array Länge

Willkommen zurück. Heute beschäftigen wir uns mit dem Thema Länge von Errays. Die Motivation für das Video heute ist, erstens, was ist die Länge eines Errays, wofür brauche ich das, wie kann ich darauf zugreifen und zweitens, was passiert, wenn ich auf ein Index zugreife, der außerhalb der Indexgrenzen des Errays liegt. Heißt soviel wie ich habe ein Erray der Länge 5 und ich greife beispielsweise auf den Index 7 zu.

Kann ja mal passieren. Die Frage ist, was, wie gehe ich damit um? Kurze Recap, wir haben bereits festgestellt, das wird bereits gesagt, dass wenn ich einen Erray anlege, deklariere und erzeuge, hier mit dem Schlüsselwort U, dass ich eine Länge fest setze und diese Länge dann im Verlauf fix ist. Das heißt, wenn ich einmal einen Erray erzeugt habe, kann ich die Länge danach nicht mehr verändern. Die Länge eines Errays gibt genau an, wie viele Elemente der Erray aufnehmen kann. Wir haben jetzt das Beispiel hier kennengelernt, wenn ich das explizit mache, das heißt, ich gebe an, der Erray hat drei Elemente oder wenn ich das implizit mache, indem ich die Elemente angebe mit KommaTageTrend, hier habe ich jetzt eben drei Elemente angegeben, also hat der Erray auch die Länge 3. Gespeichert wird das Ganze im sogenannten Attribut Length, also da kann ich dann, wenn ich der Erray stellt, mir Methoden zur Verfügung und auch Attribute und dieses Attribut Length ermöglicht mir, dass ich die Länge zu jedem Zeitpunkt abfragen kann.

Genau, Größe des Errays ist nach der Initialisierung unverenlertlich. Wie kann ich jetzt Length nutzen? Das sieht man jetzt hier unten, hier habe ich eine Anweisung, ein System Outprint Line und jetzt sage ich neben diesen Erray R hier und lasse mir die Länge ausgeben, Punkt Length, so rufe ich die das Attribut auf dieser Variablen auf und dann bekomme ich den Wert 3, jetzt hier auf der Konsole ausgegeben, weil ich ein System Outprint Line habe.

Hier vielleicht als Einschub, Errays sind ja Objekte, wir haben ja darüber gesprochen, dass es Referenz-Datentypen sind und Referenz-Datentypen verfügen immer über noch verschiedene Attribute, wie jetzt Length bei Errays und Methoden, Operationen, die man dann eben, wenn man damit arbeiten möchte, auch gut nutzen kann. Mehr dazu kommt, wenn wir uns mit der Objektorientierung beschäftigen. Was passiert jetzt, wenn ich auf ein Index zugreife, der außerhalb der Grenzen von meinem Erray sitzt. Also wir haben ja bei unserem Erray, wir haben ja immer das quasi das nullte Fach, das ist immer unser, was jetzt ganz am Anfang steht und dann haben wir das Fach Erray Punkt Length minus 1, also wir erinnern uns, wenn wir jetzt den Erray der Länge 3 haben, dann haben wir die Indizes 0, 1 und 2, genau und dann können wir auch nur auf diese Indices 0 bis 2 zugreifen. So, wenn ich jetzt auf etwas anderes zugreife, zum Beispiel auf die 5 in meinem Beispiel, dann bekomme ich eine sogenannte Exception, eine Erray-Index-Out-of-Bounce-Exception und mein Programm, also die Ausführung wird beendet.

Die Exceptions ist ein sogenannte Laufzeitfehler, das heißt je nachdem, was ich für Daten während der Laufzeit eingebe oder nutze, genau, kann so eine Exception auftreten, wie gesagt, die wird nicht übersprungen, das Programm wird beendet, aber man muss ganz ehrlich sagen, dass viele Fehler, also so ein Laufzeitfehler kann nicht zur Entwicklungszeit gesehen oder vorher gesehen werden, man kann zwar schon antizipieren und sagen, da muss ich entsprechende Maßnahmen treffen, die werden wir uns auch noch später in der Vorlesung anschauen, aber grundsätzlich ist es ebenso, dass so eine Exception auftreten kann. Hier ist dieses Beispiel, ich habe mein Int-Aray, der hat drei Stellen und ich möchte gerne an Stelle 5 etwas schreiben. So, und wie gesagt, ich habe ja hier nur Stellen 0, 1 und 2, das heißt ich kann nicht schreiben. Wie das Ganze praktisch aussieht, schauen wir uns jetzt Ich habe dafür schon mal etwas vorbereitet. Ich habe hier wieder meine klasse Demo und direkt auch eine Main Methode. Und was ich jetzt mal machen möchte, ist ich lege mir einen neuen Array an.

Wir hätten im letzten Beispiel so ein Beispiel mit meinen Lieblingsbüchern. Also ich hatte diese Favorite Books und das ist ein String Array und hier habe ich natürlich die eckigen Klammern vergessen. Ich möchte ja nicht, dass es ein einzelner String ist, sondern eine Sammlung von Strings. Und jetzt gebe ich hier wieder direkt impliziten ein paar Beispiele an, wie man das machen kann. Was hatte ich denn hier? Die Beispiele, ich hatte hier Broken. Ich habe das Beispiel, hier kommt natürlich ein Komma hin, der mit dem Wolf tanzt. Und was nehme ich noch?

Yoga am Morgen. Das sind meine drei Lieblingsbücher. Das heißt auch so viel wie mein Array hat jetzt die Länge 3 und entsprechend auch nur die Indices, nur bis 2. So, die kann ich mir jetzt zum Beispiel mal ausgeben lassen. Ich lasse mir jetzt mal das dritte Element ausgeben und zwar lasse ich mir das mal auf der Konsole ausgeben. Favorite Books an der Stelle, was haben wir denn?

2. Und wenn ich das Ganze ausführe, dann sollte das natürlich ganz normal funktionieren. Jetzt habe ich hier noch ein Fehler drin. Was habe ich denn falsch gemacht?

Fav Book. Hier stimmt es natürlich nicht. Wir wollen uns ja auch immer schon anschauen, wie man hier Fehler liest.

Hier steht Variable, Fav Books. Hier unten oben steht Symbol nicht gefunden und wenn ich mir das mal angucke, dann stimmt es natürlich nicht überein. Diese Variable mit dieser Variable. Hier fehlt ein S. Das füge ich jetzt einfach mal hier oben hinzu. So, nochmal kompilieren. So, und jetzt sehe ich hier, hier steht genau an Stelle 2, Yoga am Morgen. Ist ja auch korrekt so. Was ich jetzt auch noch mal machen möchte ist, ich lasse mir auch noch mal die Länge ausgeben von meinem Array, damit sie das auch mal gesehen haben.

Und zwar lasse ich mir mal Ausgänge geben. Die Länge des Arrays ist so plus, wie greife ich jetzt darauf zu? Na, ich rufe den Array auf, Fav Books und das Attribut Lenght darauf und das gibt mir jetzt einen Inn zurück und der wird auf der Konsole angegeben. Jetzt machen wir jetzt hier auch nochmal, ich habe hier oben im Plizid festgelegt. So, was passiert, wenn ich jetzt auf etwas zugreife, was außerhalb der Grenzen liegt, sagen wir einfach mal, ich möchte Fav Books, ich gucke mal hier, was an Stelle 5 steht. Die gibt es bei uns nicht, aber sowas kann ja mal passieren in der Entwicklung, dass so dieser Wert so reinkommt.

Und dann füge ich das Ganze mal aus und dann sehe ich, dass ich hier eine Exception bekomme und die Exception sagt mir, das ist eben diese Array Index Out of Bounds Exception und die sagt mir Index 5 Out of Bounds vor Length 3. Das ist quasi die 5 ist größer als die 3 und dementsprechend ist das außerhalb der Grenzen. Ich kann es jetzt auch mal mit dem negativen Wert probieren, ich muss das nicht immer über ein System Outprint Line machen, ich kann es so machen, Fav Books von, nehme ich doch mal minus 2, solltet es auch nicht geben, schaue ich mir das mal an oder gibt es auch nicht, lasse ich mir ausführen. Na jetzt meckert er, was sagt er mir hier? Keine Anweisung, ja, okay, stimmt natürlich, ich habe das, was ich hier rauslese, möchte ich gerne in ein String reinschreiben, also das ist hier keine vollständige Anweisung, das stimmt natürlich, String, buch nenne ich das mal, Fav Books minus 2, führe das ganze nochmal aus und sehe auch hier habe ich wieder, ach nee, das ist natürlich meine erste Exception, Entschuldigung, das muss ich natürlich hier mal rausnehmen, die wird natürlich zuerst geworfen, ganz klar, aber ich möchte ja gerne die andere haben. So und jetzt habe ich nämlich genau die gleiche Exception, aber hier sind jetzt die Werte richtig, ich habe minus 2 aufgerufen und es gibt nur die Länge 3. So, das war es erstmal zur Länge von Ares.



Array initialisieren mit der for-Schleife

Herzlich willkommen zu unserem nächsten Video zum Thema arrays Initialisierung mit der Vorschleife. Motivation heute ist, wir wollen lernen, wie wird ein array mit der Vorschleife initialisiert. Kürzes Recap, was wir schon kennengelernt haben, ist wie man arrays tatsächlich initialisiert, entweder so implizit, indem ich hier Werte angebe. Wir wissen, dass dieser array jetzt die Länge 3 hat und in den einzelnen Fächern diese Werte stehen.

Alternativ kann ich das Ganze natürlich auch ausschreiben. Ich kann erst mal ein array initialisieren oder deklarieren und hier erzeugen mit drei Fächern. Und dann kann ich ganz explizit sagen, anstelle 0 steht die Zahl 7, wie hier anstelle 1 steht die Zahl 8 und anstelle 2 steht die Zahl 9. So, die Frage ist, wenn ich jetzt große arrays habe, das geht jetzt vielleicht noch, dass ich hier drei Sachen schreibe.

Aber wenn ich jetzt große arrays schreibe, wie initialisiere ich denn so ein array, ohne dass es entweder fehleranfällig ist, wenn ich jetzt hier 100 Zahlen eintippe und mich einmal vertippe oder 100 verschiedene Anweisungen hier schreibe, das möchte ja keiner. Also die Frage ist, wie kann ich das machen? Und dafür haben wir eine wunderschöne Kontrollstruktur kennengelernt, nämlich die sogenannte Vorschleife.

Und die Vorschleife kann ich insbesondere dann gut einsetzen, wenn die Wertzuweisung, also das, was ich in die einzelnen Zellen reinschreibe, wenn das einen bestimmten Muster folgt. Und wir haben auch schon dieses Attribut kennengelernt, Length. Und hier können wir jetzt ganz genau sagen, wie, also das können wir in die Schleifenbedingungen mit aufnehmen. Das heißt, wir iterieren einmal über den array drüber. Also wir fangen bei 0 an und gehen bis 99, das sind ja unsere Indizes. Und das kann ich immer machen, indem ich dieses Attribut Length benutze. Da muss ich ja keinen festen Wert einsetzen, sondern kann das in Abhängigkeit machen von der Länge des arrays.

So, wie sieht das aus? Hier erste Zeile, ich lege ein neues array an mit 100 Elementen. Dann kommt meine Vorschleife. Ich beginne und nutze jetzt auch den Namen, damit das eindeutig ist, nämlich den Index. Ich beginne mit Index 0, also im nullten Fach. Ich lasse die Schleife laufen, solange bis der Index, also solange der Index kleiner ist als array.length. Ja, also bei 100 wäre es jetzt so, solange der Index, also läuft er bis 99. Und jedes Mal zähle ich den Index um eins hoch in jedem Schleifen-Durchlauf.

Genau, das wäre jetzt hier zum Beispiel, wenn ich alle, was wollte ich sagen, allen Fächern oder allen Fächern den gleichen Wert zu weisen, würde. Also sag ich mal, ich schreibe in alle 100 Fächer den Wert 5 rein, das würde dann so aussehen. Was wir jetzt hier machen, ist noch ein klein bisschen erweitert und zwar möchte ich sagen, der array an der Stelle Index, also wir fangen ja mit null an, ist nämlich genau der Wert Index mal Index. Also, erster Schleifen-Durchlauf, array an der Stelle 0 ist 0 mal 0, also schreibe ich dann 0 rein. Array an der Stelle 1 ist 1 mal 1, also schreibe ich dann 1 rein.

Array an der Stelle 2 ist 2 mal 2, also schreibe ich dann eine 4 rein. Und es geht so weiter. Hier ist mein Beispiel, wie das aussehen könnte. Wie gesagt, das hat ja 100 Fächer. Das heißt, hier geht es auf jeden Fall noch weiter.

Und genau, das ist eine Möglichkeit, um einen Array effizient zu initialisieren. Und dazu schauen wir uns jetzt eine Demo an. Auch hier habe ich natürlich wieder etwas vorbereitet, meine Standardklasse, meine MainMethode. Und was ich jetzt machen möchte ist, dass ich einen Array anlege. Das mache ich jetzt wie eben.

Das Beispiel, ich weiß jetzt nicht mehr genau, wie es heißt. R, glaube ich, hieß es. Und es soll ein neuer Array sein. Ein Int-Aray hatten wir gesagt und der hat die Anzahl 100. So, und jetzt nutzen wir eben unsere Vorschleife. Wir sagen, wir wollen jetzt diesen Array initialisieren und beginnen erstmal mit der Laufvariable IntIndex gleich 0.

Da beginnt es. Das machen wir, solange Index kleiner ist als R.Length. Und in jedem Schritt wird Index um 1 hochgezählt.

So, und was wir dann eben machen, ist, dass wir an der Stelle, also an der Array-Stelle Index, hier kann ich ja mal auf die verschiedenen Indices zugreifen. Das läuft jetzt eben durch von 0 bis 99. Schreib ich den Wert, den ich kriege, wenn ich, wir nehmen mal das Beispiel von eben, Index mal Index rechne. So, das kann ich ja mal ausführen. So, und ich sehe, ich sehe nichts, weil ich mir ja nichts auf der Konsole hab ausgeben lassen. Wir hatten ja eben das Beispiel oder in dem früheren Video mal das Beispiel, wenn ich jetzt hier so ein System Outprint Line rein packe.

System Outprint Line. Und zwar von diesem Array. Ich möchte jetzt gucken, ob hier alles richtig funktioniert hat. Ja, und das ganze Ausführe nochmal zur Wiederholung. Dann kriege ich ja nur diese ID.

So, was ich also auch hier machen muss, ist, ich muss auf die einzelnen Indices zugreifen. Das heißt, auch hier ist es sinnvoll, eine Vorschleife zu benutzen. Das benutze ich, wir verwende ich gleich wieder. Und zwar schreibe ich eine Vorschleife vor, und ich nehme jetzt einfach mal i gleich 0. I kleiner array.length.

i++. So, und was ich hier machen möchte, ist ein System Outprint Line. Schön formatieren hier, damit es ordentlich aussieht.

System Outprint Line. Arr an der Stelle i. Und ich mach meine Schleife zu. Genau, das passt dahin, das passt dahin, das gehört zur Methode, das ist meine Klasse. Und was er jetzt machen würde, ist, gibt mir die ganzen 100 Stellen aus. Damit es ein bisschen schöner ist, schreibe ich mal hier noch was davor. Stelle plus i hat den Wert.

So, plus das. Das mache ich jetzt mal. Also erstmal initialisieren, und dann lasse ich mir das Ganze mal ausgeben. So, und jetzt sehe ich hier, was ich für Werte habe. Alle 100 Arrays, Array-Zellen wurden hier befüllt, immer mit den Quadratzahlen. So, schnell und einfach geht das.



Arrays und die erweiterte for-Schleife

Willkommen zurück zu unserem nächsten Video, Errays, die Erweiterte Vorschleife. Die Motivation für dieses Video ist, wie funktioniert die Erweiterte Vorschleife in Java.

Kurzes Recap. Im letzten Video haben wir kennengelernt, wie man Errays mithilfe von Schleifen initialisieren kann. Nämlich indem man einfach über den Index iteriert von 0 bis kleiner der Länge und dann entsprechend etwas mit diesen einzelnen Zellen macht.

Was kann man sich natürlich aussuchen? Die Erweiterte Vorschleife existiert insbesondere dafür, um lesende Zugriffe auf sogenannte Collection-Objekte durchzuführen. Ein Collection-Objekt, wie der Name sagt, ist ein Objekt, das eine Sammlung von Objekten ist und das sind ja Errays auch. Die Sintags von der Erweiterten Schleife sieht dabei so aus. Auch hier habe ich, sieht ein bisschen ähnlich aus wie in der Vorschleife, vor, aber anstatt, dass ich jetzt hier drei Elemente habe, wird jetzt hier angegeben, das Object-Element, also hier muss ein Datentyp rein. Der Datentyp heißt Element und hier, Doppelpunkt, kommt der Name der Collection rein.

Vielleicht erinnern wir uns noch an den letzten Erray, da hatten wir ja ein Int-Erray und der hieß ARR, würde also hier stehen, Int-Element-Doppelpunkt-ARR. Hier unten steht auch noch Object-Element-Collection bedeutet hier für jedes Element, also für jedes einzelne Fach aus dieser Collection. Darüber iteriere ich. Sieht man jetzt hier mal im Vergleich, hier oben habe ich meine klassische Vorschleife mit meinen drei Elementen.

Ich iteriere ganz explizit von 0 bis 1 kleiner als die Länge des Errays und in jedem Schritt tue ich etwas, also lese ich hier gerade tatsächlich etwas aus dem Erray und schreibe das in eine Variablerein. Die Erweiterte Vorschleife ist deutlich kürzer. Ich habe hier eben auch das Schlüsselwort vor und genau das, was ich eben sagte, ich habe den Datentyp Int, das ist der Name Element, ist hier die Collection. Und jetzt schauen wir uns das ganz mal praktisch an. So, wir knüpfen jetzt direkt mal an unser Beispiel aus dem letzten Video an. Wir erinnern uns, wir haben jetzt hier diese Vorschleife genutzt, um unseren Erray zu initialisieren. Und was ich jetzt hier rausgelöscht habe, wir haben danach eine Vorschleife benutzt, um den Erray ausgeben zu lassen.

Dafür benutzen wir jetzt eine Vorschleife, also die erweiterte Vorschleife, die dann wie folgt aussieht. Vor, wir haben ein Int Erray und wir nennen das einfach mal Element oder wir können es auch LM nennen, es ist eigentlich egal, wie wir es nennen, das ist uns selbst überlassen. Und dieses LM sitzt in dieser Collection drin, das ist jetzt hier genau der Name meines Errays. Und was jetzt hier passiert ist, dass ich das Ganze auf der Konsole ausgeben lasse, Print Line. So, und wenn ich das Ganze jetzt mal ausführe, das ist natürlich falsch, hier gebe ich jetzt gerade den Erray aus, ich muss natürlich auf dieses Element hier zu greifen, rechtzeitig gesehen so.

Und dann führe ich das Ganze mal aus und dann sehen Sie auch, jetzt habe ich hier wieder die ganzen Quadratzahlen von allen 100 Elementen von 0 bis 9,90. Und so kann man sehr schön die erweiterte Vorschleife anwenden. Was man hier nicht machen kann, ist, dass ich jetzt hier Werte im Erray verändern kann.

Wenn ich jetzt Werte im Erray verändern möchte, dann brauche ich wirklich diesen Zugriff hier, dass ich sage, schreibe hier was rein. Ich kann jetzt diese erweiterte Vorschleife nicht benutzen, um mir zum Beispiel genau diese Funktionalität hier wieder also darzustellen. Wenn Sie sich überlegen, ich habe jetzt nur dieses LM zur Verfügung. Ich weiß auch nicht, welche Zahl das hat, also welchen Index das hat, ob das 0, 1, 2, 3, 4, 5 ist. Dementsprechend könnte ich hier sowas nicht machen. Also ich kann hier wirklich nur das als für den Lesenden-Einsatz einsetzen. Aber da wir natürlich oft Errays lesen, ist das hier sehr passend.