Kontrollstrukturen: Einführung

Hallo zusammen, wir machen weiter mit den Grundlagen der Programmierung und das Thema für die nächsten Videos werden Kontrollstrukturen sein. Deswegen möchte ich hier zuallererst hinführen zu den Fällen, wo wir eine Kontrollstruktur brauchen, wo die Kontrollstruktur sinnvoll für uns ist. Und dann natürlich auch gleich dabei auflösen, was gibt es überhaupt für Kontrollstrukturen, was hat es damit überhaupt auf sich.

Und ich habe dafür mal ein paar Beispiele mitgebracht. Und das erste wäre eine Sache, die wir an sich auch schon machen können, nämlich die Berechnung von Quadratzeiten. Wenn wir jetzt zum Beispiel sagen wollen, wir wollen alle Quadratzahlen zwischen 1 und 50 ausgeben lassen auf der Konsole, warum auch immer, dann könnten wir sowas hier machen. Wir könnten sagen 1 und dann zum Quadrat ist gleich, das ist natürlich nur Text, der ausgegeben wird. Hier würde dann die eigentliche Berechnung stattfinden und dann sagen wir 1 mal 1.

Ja genau, dasselbe könnte ich dann nochmal machen für die 2, 2 hoch 2 ist das Ergebnis von 2 mal 2 und so weiter und so fort. Und wer jetzt so Angst hat, dass ich bis 50 alle Zahlen austippe, keine Sorge, ich deutete das hier mal so an durch 3 Punkte und sage hier 50 zum Quadrat, als die letzte Zahl, die wir gesagt hatten, 50 zum Quadrat ist gleich das Ergebnis von 50 mal 50. Ich führ das ganze mal aus, ja so würde das auf der Konsole aussehen. Was wir jetzt aber schon beim Programmieren gesehen haben, ist so ganz praktisch ist das irgendwie nicht 50 mal quasi dieselbe Sache hinzuschreiben.

Spätestens wenn ich jetzt sage, ich will alle Quadratzahlen zwischen 1 und 100 oder 500 oder 1000 oder was auch immer, dann wird es ganz ganz ganz viel doppelte Arbeit. Was wir uns hier angucken wollen, was quasi die Motivation ist, ist das Thema Schleifen. Die nehme ich dafür sorgen, dass wir bestimmten Code mehrfach ausführen können. Wir gucken uns dabei auch an, wie wir sowas umsetzen können, wie die Tatsache, dass hier ja nicht genau der selbe Code immer ausgeführt wird, sondern dass wir hier eben die 1, die 2 und so weiter und so fort bis zur 50 quadrieren wollen. Das heißt, hier gucken wir auch noch mal darauf, wie man damit arbeiten kann, dass zum Beispiel ein Zahlraum zwischen 1 und 50 abgedeckt wird.

Aber wir sehen auf jeden Fall, um sich diese doppelte Arbeit zu sparen, gibt es vielleicht einen ganz netten Java Mechanismus. Es gibt sogar 3 Arten von Schleifen, aber als große Überschrift das Thema Schleifen, die wir uns angucken werden, um eben solchen doppelten Schreibaufwand oft zu vermeiden. Okay, ein anderes Thema und hier mache ich vielleicht am Anfang eine kleine Wiederholung, während die Verzweigungen, ich hatte eine Wiederholung versprochen, deswegen schreibe ich Wiederholung ternary operator. Das ist ein Beispiel, was wir auch mal in der Vorlesung gemeinsam gemacht hatten. Da hatten wir nämlich gesagt, wir haben ein float, Note und die Note ist mal deswegen 1,3 bzw.

1,3f. Und wir wollen uns dann auf der Konsole ausgeben lassen, ob man mit dieser 1,3 oder mit der Note, die da entsprechend steht, bestanden hat oder nicht. Das heißt, hier könnte ich jetzt den ternary operator verwenden, da das war dieses sperrige Ding mit Fragezeichen, doppelpunkt und irgendwie drei Werten insgesamt. Gucken wir uns genau an. Das erste ist nämlich der logische Ausdruck, das heißt meine Bedingung. Wenn die Note kleiner ist als 5, das heißt ich habe bestanden, dann abgetrennt durch so ein Fragezeichen, soll dieser Wert hier genommen werden, da sagen wir einfach, hat bestanden und wenn nicht, abgetrennt durch so ein doppelpunkt, schreiben wir oder geben wir an, was ansonsten genommen werden soll, nämlich, es hat nicht bestanden. Wenn ich das auf der Konsole mal anzeigen lasse, dann würde ich jetzt hier sehen, hat bestanden, okay, die Note haben wir jetzt nicht mit ausgeben lassen, aber man sieht, ja, die 1,3 ist natürlich eine gute Note, dementsprechend habe ich bestanden, weil die Note kleiner ist als 5 und dementsprechend die Bedingung true ist, dementsprechend wird dieser Wert hier genommen. Und diesen ternary operator muss ich jetzt nicht unbedingt in so einem System und Print line verwenden, ein anderer geeigneter Fall wäre auch so eine Wertzuweisung, also dass ich vielleicht direkt eine variablen Wertzuweise abhängig von einem Wahrheitswert, hatten wir gemacht, gibt es ein extra Video dazu, worauf ich jetzt aber hinaus will, ist, vielleicht gibt es ja eine Stelle, wo ich mit diesem ternary operator nicht wirklich weit komme, wenn wir, in dem ich den Fall jetzt noch ein bisschen weiterdenken und sagen, wir haben eine Klausur geschrieben und wir haben bestanden oder eben nicht bestanden, dann wird ja vielleicht, keine Ahnung, wie es ganz genau an der HTW oder am LSF funktioniert, aber dann wird ja vielleicht irgendwas eingeleitet und ich spinne jetzt einfach mal rum, wir könnten ja zum Beispiel sagen, wenn bestanden bzw. wenn Note kleiner ist als 5, dann und dann sagen wir, keine Ahnung, ich werde zum nächsten Kurs zugelassen, Zulassung zum nächsten Kurs, Klausur, keine Ahnung, abgehakt, ein Anführungszeichen, im LSF oder im Notensystem oder was auch immer, rein fiktives Beispiel und auf der anderen Seite, wenn ich eben nicht bestanden habe, wenn nicht, dann soll, weiß ich nicht, Wiederholung des Kurses, Wiederholung der Klausur, was auch immer bzw.

sagen wir mal, Wiederholung der Klausur und keine Zulassung zum nächsten Kurs, wie auch immer, ja also als Beispiel und wir hatten letzte Woche Methoden kennengelernt, hier könnte man sich vorstellen, dass eben die entsprechenden Methoden aufgerufen werden, abhängig davon, ob ich eben eine Note geschrieben habe, die besser als 5 oder ob ich eben eine Note geschrieben habe, die nicht besser als 5, sprich, eine 5, sprich, nicht bestanden. Und hier schreibe ich jetzt deswegen mal ganz groß drüber, die Motivation, wären sogenannte Abzweigungen, Abzweigungen, ja wie gesagt, wenn ein Wahrheitswert zutrifft, dann mache ich das, wenn ein Wahrheitswert nicht zutrifft, mache ich was anderes. Auf den ersten Blick vielleicht relativ ähnlich klingt das Thema, wir wissen gerade auch alternativ einsetzbar, wir gucken uns den genauen Unterschied auch nochmal an, ist das Thema Fallunterscheidungen, was ich zeigen möchte, Modifikation, Fallunterscheidungen und ich schreibe jetzt, ich kann schon mal andeuten, keine Ahnung, es gibt irgendein Geburtstag zu feiern, meine Dwegen und dann sage ich, das Alter ist gleich irgendwas, wir sagen jetzt mal jemand ist gerade 18 geworden und abhängig davon, was für ein Geburtstag gefeiert wird, möchte ich vielleicht einen unterschiedlichen Text anzeigen und zwar möchte ich genau rausheben, wenn jemand 16 wird und wenn jemand 18 wird, mit 18 kann ich sagen, alles Gute zur Volljährigkeit, mit 16 kann ich sagen, herzlichen Glückwunsch trinken Bier oder sowas, weil man mit 16 Bier trinken darf und ansonsten, also wenn jemand nicht 16 oder 18 wird, egal welches Alter, ansonsten möchte ich einfach sagen, alles Gute zum Geburtstag. Und hier gibt es auch in Jarvan einen Mechanismus, wie gesagt, das sieht auf den ersten Blick so ein bisschen ähnlich aus, wie das hier oben, wir gucken uns den genauen Unterschied auch noch mal an, wo ich sagen kann, wenn Fall 1, dann möchte ich das machen, wenn Fall 2 dann das und so weiter und so fort und wir hatten gesagt, wenn 18, dann wollen wir sagen, keine Ahnung, alles Gute zur Volljährigkeit, wenn 16, dann Bier und wenn einfach, ansonsten, alles Gute, ja, ist ein kleines Beispiel. Wir haben also hier jetzt nochmal ganz kurz zusammenfassend uns drei Fälle angeguckt, drei Motivationen für die nächsten Videos, einmal eine Motivation zu schleifen, da gibt es genau drei Stück in Jarvan, die man verwenden kann. An sich dieses Beispiel hier ist eine Sache, die man hätte umsetzen können, wir wollen aber diese repetitive Arbeit irgendwie uns ersparen, dann hatten wir uns angeguckt, also wir haben uns einmal angeguckt, was kann ich überhaupt schon im Bereich Abzweigungen durch diesen Ternoreoperator, aber wo kommt dann der Ternoreoperator an seine Grenzen und soll auch gar nicht unbedingt mehr leisten, als das, was er tut, wie müsste ich jetzt vorgehen, wenn ich im Programm wirklich abzweigen möchte, sprich zum Beispiel, wenn ich sage, wenn man bestanden hat, passiert das, wenn man nicht bestanden hat, passiert was anderes und zu guter Letzt gucken wir uns noch Fallunterscheidungen an, nämlich die Prüfung für konkrete Fälle, wenn man genau achten wird oder genau sechzen wird, dann soll ein anderer Text auf der Konsole ausgegeben werden, ansonsten gebe ich einfach aus, alles Gute. Das war die kleine Motivation und dann kommen jetzt die Videos zu den Details, zu den einzelnen Themen, Schleifen, Abzweigungen und Fallunterscheidungen.



Sequenzen

Hallo, wir machen weiter mit den Grundlagen der Programmierung. Das große Thema dieser Videos ist ja jetzt Kontrollstrukturen. Hatt ich im letzten Video eingeführt, angeteaselt, auch versprochen, dass wir damit weitermachen. Ich schiebe aber nochmal ein Thema ein, nämlich Sequenzen.

Das ist vielleicht unter dem Namen unbekannt, aber eigentlich eine Sache, die grundsätzlich schon bekannt ist, die wir uns einfach nochmal vor Augen führen wollen, um dann richtig mit Kontrollstrukturen loslegen zu können. Wir gucken uns an, was eine Sequenz ganz genau ist, bzw. verbunden mit dem letzten Thema Methoden, wie eine Sequenz über mehrere Methoden hinweg aussieht. Und ich habe noch eine dritte Folie tatsächlich dabei, die eigentlich auch schon die erste Frage beantwortet.

Eine Sequenz ist nichts anderes, als was von oben nach unten ausgeführt wird. Die Folie zeigt auch noch so ein Struktogramm. Struktogramm ist die Möglichkeit, Code oder Workflows oder wie auch immer man es nennen will, mit Hilfe geometrischer Formen darzustellen. Bei so einer Sequenz, also von Code, der einfach von oben nach unten durchgearbeitet wird, sieht das Struktogramm auch entsprechend simpel aus.

Wir haben hier letzten Endes nur ein Rechtegg mit diesem Verarbeitungsblock, wie gesagt, von oben nach unten, wenig überraschend, wenig spektakulär, genau das, was wir bis jetzt eigentlich immer gemacht haben. Ich zeige das Ganze nochmal an einem Code Beispiel. Wir haben hier unsere Main-Methode. Wir haben in der ersten Vorlesung irgendwie sowas gemacht. In i ist irgendein Zahl, dann zählen wir da irgendwas dazu, meinetwegen 456 und geben das Ganze auf der Konsole aus. System Outprint Line von i, ich speichere das Ganze mal und gebe es aus. Ja, und kriege eben hier 579 angezeigt.

Warum? Weil er erstmal i initialisiert und deklariert 123 als Wert, dann werden 456 dazugezählt und dann wird das Ganze ausgegeben. Ja, genau in der Reihenfolge von oben nach unten, in der wir es hinschreiben, wenig überraschend. Ich schreibe trotzdem nochmal dazu, in welcher Reihenfolge das ausgewertet wird. Ganz einfach.

Ja, 1, 2, 3, relativ simpel. Das Thema der letzten Woche waren ja Methoden. Da nehme ich auch nochmal ein Beispiel mit rein und sag private, was weiß ich, int von mir aus, quadrat und das nimmt ein Parameter entgegen, den integer, nennen wir mal entwegen i und gibt dann i mal i zurück. Gucken wir uns das Ganze mal an, wenn ich jetzt hier weitermache und zum Beispiel sag int q ist das Quadrat von i, das ist hier der Methodename natürlich, den ich vorhin angelegt habe. Also hier habe ich noch ein Static vergessen. Ja, q soll einfach den Wert von i zum Quadrat haben, das heißt dafür rufen wir die Methode auf und ich gebe dann meinetwegen nochmal q auf der Konsole aus. So, speicher das Ganze fürs Aus. In dem Fall, irgendeine relativ große Zahl, das Quadrat von 123, wird natürlich das Quadrat dazwischen berechnet.

Das heißt, wenn wir uns jetzt überlegen, wie diese Sequenz aussehen würde, es bleibt eine Sequenz, also es wird weiterhin Code von oben nach unten durchgearbeitet. Es ist nicht mehr ganz so schön einfach und übersichtlich wie hier, dass wir einfach sagen, okay, Zeile für Zeile, sondern es springt dann natürlich zwischen den Zeilen hin und her. Das heißt, diese Zeile hier wird quasi an Vörterstelle jetzt aufgerufen, dann wird das hier berechnet bzw.

zurückgegeben, das hier wäre die 5 und das hier wäre die 6. Soweit aber auch ganz logisch, weil wir natürlich hier diese Methode aufrufen und natürlich q dann auch den Wert von, oder den Rückgabewert von dieser Methode zurückgeben möchten. Das heißt, das Quadrat wird berechnet, erst mal wird diese Methode hier aufgerufen und i mal i für in unserem Fall 123, also 123 mal 123 ausgerechnet und dann wird der Wert zurückgegeben, wird in q abgelegt und erst dann kann ich natürlich auch q ausgeben. Das heißt, selbst wenn wir mehrere Methoden haben, ich könnte jetzt auch beliebig das Ganze irgendwie größer machen, ich könnte jetzt natürlich auch noch hier irgendwelche Anweisungen reinpacken, mache ich aber nicht das Beispiel, das ist glaube ich deutlich genug, selbst wenn ich verschiedene Methoden habe, reden wir über Sequenzen, die Reihenfolge ist vielleicht nicht mehr ganz von oben nach unten so zu lesen, aber sobald man sieht, welche Methoden waren und wo aufgerufen werden, ist relativ klar, in welcher Reihenfolge der Code durchlaufen wird. Wie gesagt, das war nur eine ganz kleine Wiederholung von einer eigentlich bekannten Sache, nur mit einem anderen Namen diesmal, Sequenzen. Und im Gegensatz zu Sequenzen, gucken wir uns dann auch sofort die Kontrollstrukturen an.



while-Schleife

Weiter geht es mit den Grundlagen der Programmierung. Thema der heutigen Videos sind ja Kontrollstrukturen und diesmal fangen wir in Anführungszeichen richtig an, nämlich mit der ersten Schleife, der sogenannten Wildschleife.

Ich hatte im ersten Video zur Kontrollstruktur gesagt, es gibt drei verschiedene Schleifen in Java, dementsprechend wird diese Motivationsfolie auch relativ ähnlich aus in den nächsten drei Videos. Wir gucken uns immer an, wie ist die jeweilige Schleife aufgebaut und wann ist die jeweilige Schleife sinnvoll, hier wie gesagt in diesem Video konkret anhand der Wildschleife. Ich habe hier auch wieder so ein Struktogramm dabei, auch das ist schon bekannt aus dem letzten Video zum Thema Sequenzen. Sieht relativ ähnlich aus. Wir sehen aber, dass dieser Verarbeitungsblock von so einer Bedingung umrandet ist bzw. der Verarbeitungsblock, das Verarbeitungsrecht in dem Bedingungsrecht liegt. Diese Bedingung liegt in Anführungszeichen da drauf, ist also vorausgehend, was es damit auf sich hat, zeige ich sofort.

Die Aussage von dem Struktogramm ist einfach, der Verarbeitungsblock wird so lange ausgeführt, wie die Bedingung true ist, wie diese Bedingung erfüllt ist und wenn nicht wird eben auch nicht oder sobald die Bedingung nicht oder nicht mehr erfüllt ist, wird mein Code auch nicht mehr ausgeführt. Ich würde sagen, wir springen direkt zu einem Beispiel und hier hätte ich jetzt erstmal vorgeschlagen, dass wir uns das Würfeln angucken. Ich weiß nicht, ob es so ein Spiel gibt, aber ich habe mir einfach überlegt, wir könnten ja sagen, wir wollen eine Zahl würfeln, meinetwegen die, was ich nehme mal die 5 und sobald diese 5 gewürfelt worden ist, ist alles gut. Wenn ich die 5 aber nicht würfeln von Anfang an, dann muss ich so oft nachwürfeln, bis ich eine 5 gewürfelt habe und wir zählen dabei auch gleich mit, wie oft ich nachwürfeln musste, keine Ahnung, ob es so ein Spiel gibt, wo man dann irgendwie Strafpunkte oder irgendwas dafür bekommt, die ich öfter mal nachwürfeln musste. Gucken wir uns einfach mal an, wie man so etwas in Java umsetzen könnte.

Also wir würfeln zumindest so lange, bis wir eine 5 haben. Es führt mich dazu auch an der Stelle direkt am Anfang mal zu zeigen, eine Möglichkeit, wie man in Java Zufallszahlen generieren lassen kann. Wir hatten eher gesagt, wir wollen würfeln, dementsprechend eignet sich ein Integer, ja ganze Zahl und eine Möglichkeit für Zufallszahlen in Java ist das Mathpunkt random. Das gibt mir eine Zufallszahl zurück. Um genau zu sein, der Zufallszahl zwischen 0 und 0,9999 irgendwas, wenn ich das jetzt hier ausführe, kriege ich deswegen auch ein Compilerfehler, hat natürlich zwei Probleme. 0,9999 irgendwas heißt, wir haben eine Zahl mit Nachkommastellen, die in den Integer zu speichern funktioniert natürlich nicht. Auf der anderen Seite ist es auch inhaltlich Quatsch, wenn wir überlegen, wir wollen eigentlich erwürfeln, also eigentlich eine Zahl zwischen 1 und 6. Das erste, was wir hier also machen müssten, wäre den ganzen Ausdruck mal zu casten.

Mache ich jetzt mal, führe ich auch mal aus, scheint schon mal zu funktionieren, insofern, dass es gültiges Java ist. Wenn man aber mal genau drauf schaut und genau nachdenkt, sieht man, okay, Mathpunkt random gibt mir irgendwas zwischen 0 und 0,9999 irgendwas zurück. Wenn ich das jetzt caste zu einem Integer, sprich die Nachkommastellen abschneide einfach, habe ich effektiv immer 0. Es fehlt also noch ein bisschen was. Und hier setze ich schon mal ein Weiservoraussicht Klammern außen rum.

Möchte ich jetzt erstmal, dass ein größerer Wertebereich abgedeckt wird. Dafür multipliziere ich das sinnvollerweise mit 6. Das führt dazu, dass ich eben im kleinsten Fall, wenn Mathpunkt random 0 zurück gibt, 0 mal 6 habe, dann kommt 0 raus. Aber wenn Mathpunkt random 0,9999 irgendwas zurück gibt, dann wird dieses 0,9999 irgendwas mit 6 multipliziert. Das heißt, ich habe 5,9999 irgendwas.

Das heißt, wenn ich danach die Nachkommastellen abschneiden würde, indem ich zum Integer caste, hätte ich eine Zahl 0, 1, 2, 3, 4 oder 5. Das sieht schon mal ganz gut aus. Wir sind in der richtigen Richtung unterwegs.

Eine Sache fehlt noch und zwar einfach plus 1, so dass ich 1, 2, 3, 4, 5 oder 6 habe als Zufallszahl. Ich würde sagen, wir probieren das Ganze mal aus. System Out, Print Line, Würfel, speichern das Ganze ab. Hier haben wir die 5 gewürfelt, 2, 2 und so weiter. Scheint also zu funktionieren.

Super. Hat noch nicht allzu viel mit Schleifen zu tun bis hierhin. Das wollen wir jetzt machen. Und zwar hatten wir ja gesagt, wir wollen so lange Würfeln bis wir eine 5 haben bzw. so oft nach Würfeln wie nötig bis wir eine 5 haben.

Ich würde hier deswegen auch mal so ein Count für dieses Nachwürfel nochmal direkt mit anlegen und das System Out, Print Line, können wir hier runter schieben. Genau. Was wir uns jetzt angucken wollen, ist natürlich eine Wildschleife. Und hier den folgenden Aufbau.

Ich schreibe hin. Wild, dann Runde klammern. In diese Runde klammern kommt gleich unsere Bedingung. Und geschweifte Klammern, in diese geschweifte Klammern kommt dann der Code der eigentlich ausgeführt werden soll. Hier wie gesagt noch mal als Struktogramm. Wir haben die Bedingung vorausgehend in die Runde klammern bzw. dann der Code der eigentlich ausgeführt werden soll. Hier in die geschweifte Klammer.

klammern. Okay, erst mal gucken wir uns die Bedingung an. Die Bedingung wäre ja einfach weil Würfel ungleich fünf. Ja, wir hatten hier gesagt, wir wollten die fünf Würfeln.

Und was wir machen, wenn keine fünf gewürfelt worden ist oder so lange keine fünf gewürfelt ist, ist, wir wollen ganz frech nochmal Würfeln. Ich gupe hier jetzt mal einfach von hier oben. Und auf der anderen Seite diese Zahlen hochzellen, die ausdrücken, wie oft nachgewürfelt worden ist. Okay, ich würde sagen, wir geben auch hier mal was auf der Konsole aus, nämlich einmal den gewürfelten Wert. Das wäre natürlich hier an der Stelle immer fünf, hoffentlich zumindest, weil wir gesagt haben, wir wollen so lange nachwürfeln, bis eine fünf auch gewürfelt worden ist. Und auf der anderen Seite wollen wir auch noch, ich vermute hier ein bisschen rum, auf der anderen Seite wollen wir auch noch anzeigen, wie oft nachgewürfelt worden ist. Dafür finden wir diese Variable Count, die das ja für uns hochzählt. Okay, ich speichere mal ab, führ das ganze aus. Ja, Würfel ist erwartungsgemäß fünf, nachgewürfelt wurde sechsmal, ich führ das ganze nochmal aus, wieder sechsmal, 23 mal, nullmal.

Super. Ich habe davor schon ein Video gedreht, was ich dann abgebrochen habe, weil ich so oft würfeln musste, dass ich irgendwie euch nicht langweilen wollte dabei. Auf den Fall wollte ich jetzt noch mal zu sprechen kommen. Wir sehen, es wurde nullmal nachgewürfelt.

Was heißt das konkret? Das bedeutet, dass von Anfang an, also hier direkt in Zeile fünf, als wird das allererste mal so eine Zufallstahl haben generieren lassen, dass direkt hier fünf der variable Würfel zugewiesen worden ist. Es führt dazu, dass hier bei der Schleife beim Prüfen der Bedingung von Anfang an gesagt wird, na gut, Würfel, ungleich fünf, die Bedingung ist false. Ja, von Anfang an ist der Wert fünf, dementsprechend muss ich gar nicht nachwürfeln. Das heißt, durch dieses vorgelagerte Prüfen wird hier gar nicht der Code durchlaufen. Ja, wir müssen nicht nachwürfeln in dem Fall, wovon Anfang an oder wo beim ersten Mal schon ne fünf gewürfelt worden ist. Das ist dieses, ja, hier nochmal bei dem Sprungprogramm, was mit dieser vorausgehenden Prüfung gemeint ist.

Der Code wird exakt nullmal ausgeführt, sofern von Anfang an die Bedingung true ist. Zweites Beispiel, was ich hier zeigen wollte, ist, was ich auch schon Eingangs mal gezeigt hatte in der ersten, am ersten Video, nämlich dieses Beispiel mit den Quadratzahlen. Das würde ich jetzt auch hier einfach mal machen. Ich setze hier mal so eine Trendlinie rein für uns mit einer Wildschleife.

Wir kopieren oder wir können relativ viel von hier oben übernehmen. Ja, wir nehmen eine Wildschleife, weil Bedingung und dann der Code, der ausgeführt werden soll. Wir brauchen hier natürlich noch die jeweilige Zahl, die hochgezählt werden soll oder die quadriert werden soll. Speicher ich mal ab in einem Integer, ich nenne die einfach mal i. Wir hatten angefangen mit der 1 und hatten gesagt, solange die Zahlen von 1 bis 50, ich nehme hier mal erstmal in den Code Block das, was wir ausgeben lassen wollen jeweils, nämlich i zum Quadrat ist gleich und dann hier das Ergebnis von i und was wir gesagt haben ist i kleiner bzw. kleiner gleich 50. Wenn ich das jetzt hier ausführe, dann wird was Schlimmes passieren, nämlich der Code hat gar nicht mehr aufzulaufen.

Ich habe hier so eine sogenannte Endloschleife programmiert, nicht gut. Es fehlt noch eine Sache und zwar muss ich irgendwie, ja wenn man genau hinguckt, ich füße nochmal aus, dann wurde hier die ganze Zeit 1 hoch 2 ist gleich 1 ausgegeben, was einfach dazu führt, i wird nie größer sein als 1. Dementsprechend wird die Bedingung hier immer true sein, der Wert von i ist immer 1 und er gibt eben immer dasselbe aus. Das wollen wir nicht, was uns also noch fehlt, wäre hier so ein Hochzellen von i, ich speichere das ganze mal ab, führe das ganze mal aus und hier würde ich jetzt eben tatsächlich die Zahlen zwischen 51 angezeigt bekommen. Persönliche Meinung, wir gucken uns danach gleich den nächsten Schleifentypen an. Ich bin der Meinung, Wildschleifen kann man sehr gerne verwenden für jeglichen Fall, wo irgendwie von vornherein nicht klar ist, wie oft ich den Codeblock hier durchlaufe, wenn klar ist, wie oft ich den Codeblock durchlaufen will, also hier zum Beispiel genau in den Bereich zwischen 51 abdecken will, eignet sich vielleicht die nächste Schleife, die ich gleich vorstellen will. Auf der anderen Seite, wenn man sagt, ich fühle mich wohl mit dieser Struktur von Wild, also ich finde das ist übersichtlich, ich verstehe, was da passiert und der andere Schleifentyp oder der andere Schreibweise ist mir irgendwie noch so ein bisschen fremd, dann ist es natürlich völlig valide, Wild zu nehmen.



for-Schleife

Abruptes Ende im letzten Video. Ich hatte angeteasert, es gibt vielleicht eine Alternative zur Wildschleife in manchen Fällen. Die sogenannte Vorschleife, die gucken wir uns hier an.

Auch hier wieder, wie ist die Vorschleife aufgebaut, wann ist die Vorschleife sinnvoll. In Klammern, vor allem im Gegensatz zur Wildschleife. Auch hier habe ich wieder ein Struktogramm dabei. Das sieht eigentlich ziemlich ähnlich aus zu dem von der Wildschleife.

Wir haben wieder eine Bedingung, die vorausgehend ist, also die sozusagen auf dem Schleifenblock liegt. Hier steht jetzt i ist gleich 0, i kleiner, 10, i plus plus, keine Ahnung, was es damit auf sich hat. Gucken wir uns sofort an. Ja, im Endeffekt ähnlich oder genau gleich wie die Wildschleife. Die Vorschleife vereinheitlich nur so ein bisschen Sündtags, die wir bei der Wildschleife ein bisschen anders geschrieben haben.

Ich würde sagen, wir springen direkt zum Code. Ich habe hier das Beispiel von gerade eben zur der Wildschleife dabei und würde einfach vorschlagen, wir formulieren genau dasselbe in einer Vorschleife. Und die Vorschleife vereinheitlich so ein bisschen Sachen, die wir bei der Wildschleife extra schreiben mussten, in einem. Ich zeige hier einmal, wie die Sündtags der Vorschleife aussieht. Wir haben hier wieder unseren Schleifenblock mit geschweiften Klammern. Spannend ist aber hier dieser Part, den ich in die Runde klammern schreibe.

Hier packe ich nämlich genau drei Sachen rein. Einmal eine Initialisierung, das heißt, in i ist gleich 1, weil wir mit 1 anfangen wollen. Dann getrennt durch ein Semi-Colon die Schleifenbedingung. Das wäre, wenn wir jetzt genau dasselbe Beispiel wie oben machen wollen, i kleiner gleich 50.

Und auf der anderen Seite hier können wir direkt einen Inkrement zum Beispiel hinzufügen, also irgendwas, was passieren soll, nachdem die Schleife durchlaufen worden ist. Hier könnte ich sagen i++. Er wird jetzt hier meckern, wenn ich das ganze Versuch ausführen, weil diese Variable i natürlich oben schon belegt worden ist. In dem Moment würde ich das jetzt hier auch mal rausschmeißen. Bisschenweise die Zeile kopiere ich mir vielleicht mal, ansonsten schmeiß ich es raus.

Wir hätten jetzt hier quasi auf eine andere Schreibweise genau dasselbe gemacht wie oben. Ich füge das hier noch ein, damit es wirklich vollständig ist. Wir haben nämlich gesagt, wir wollen alle Zahlen zwischen 1 und 50 ausgeben lassen bzw. deren Quadrat ausgeben lassen. Ich führ das ganze mal aus und wir sehen, wir kommen zum selben Ergebnis. Der Punkt bei der Vorschleife ist eben auf den ersten Blick vielleicht ein bisschen erschlagen, ein bisschen gewöhnungsbedürftig. Die Weilschleife ist sicherlich ein bisschen einfacher zu lesen, gerade beim ersten Mal. Wenn man aber versteht, was diese drei Teile hier machen bei der Vorschleife, ist es eigentlich eine ziemlich schlanke Schreibweise, um solche bestimmten Wertebereiche zum Beispiel abzudecken.

Ich schreibe hier noch mal auf vor und hier das erste ist die Initialisierung von einer Variable i, so genannte Laufvariable. Dann haben wir die Bedingungen, also das, was wir auch bei der Walschleife hingeschrieben hätten. Semikolons, damit nicht der Eindruck entsteht. Hier ist ein Komma dahin und auf der anderen Seite ein Update, also zum Beispiel i++ als Inkrement.

Ich könnte natürlich auch sagen i, weiß ich nicht, anderes Beispiel i++ gleich 10, i++ ist relativ typisch und wenn ich jetzt einfach sage plus gleich 10, kriege ich eben nur 11, 11, 21, 31 und 41 dargestellt. Funktioniert also genauso. Das ist die grundsätzliche Sündungsdach der Forschleife. Ich würde jetzt vielleicht auch eine Sache Vollständigkeit halber hier zeigen. Wir hatten ja Methoden kennengelernt, das wollte ich jetzt hier nicht ausklammern.

Ich mache hier mal eine neue Methode, Public static void print square und die kriegt irgendeine Zahl als Parameter und gibt dann genau das hier auf der Konsole aus. Worauf ich hinaus will, ist einfach nur natürlich kann ich auch aus so einer Schleife raus direkt Methoden aufrufen. Wenn ich jetzt hier sage print square für meine variabile i jeweils, dann funktioniert das ganz genauso. Jetzt habe ich hier das mit plus gleich 10. Wenn ich hier sage plus plus wieder, dann habe ich natürlich alle Zahlen zwischen 51, so wie gewollt. Vielleicht noch ein kleiner Hinweis. In 95 Prozent der Fälle ist das hier genau das, was ich haben will.

Ich habe irgendwie ganz klassischen Integer, den ich irgendwie initialisieren, habe irgendeine Bedingungen, in die natürlich auch dieser Integer irgendwie gehört. Klassischerweise und auf der anderen Seite habe ich hier ein i plus plus oder irgendeinen Update. Das ist die Theorie.

In 95 Prozent der Fälle ist das auch die Praxis. Es ist aber theoretisch auch so, dass ich gar nicht mal die einzelnen Bestandteile von dieser Forschleife hinschreiben muss. Also wenn ich jetzt zum Beispiel aus irgendeinem Grund hier die Bedingungen weglassen will, kann ich das grundsätzlich machen. Dann hätte ich sozusagen eine Endloschleife programmiert. Ich kann das mal ausführen. Sieht irgendwie nicht gut aus. Ich breche das Ganze mal lieber ab. Würde theoretisch funktionieren, das ist an sich gültiger Java Code. Genauso könnte ich hier dieses i plus plus weglassen.

Würde uns zu dem selben Szenario führen wie vorhin bei der Wildschleife, wo einfach quasi dadurch eine Endloschleife entsteht, dass die 1 nicht hochgezählt wird. Also dass die Bedingung hier immer true ist, weil immer die Zahl 1 kleiner ist als 50. Ich muss mich also schon darum kümmern, das hoch zu zählen.

Ich wollte es nur einmal zeigen. Rein theoretisch ist es so, dass ich keine dieser Sachen hinschreiben muss. Ich muss zwar diese drei Semikolen setzen, ich kann aber beliebig auch irgendwas freilassen. In den allermeisten Fällen ist es Quatsch. Also in den allermeisten Fällen ist es nicht so, dass ich hier irgendwie irgendein Steaderleih lassen müsste. Ich könnte hier natürlich auch eine andere Bedingung, die nicht aufs i bezogen ist, reinpacken. Also ich habe hier eine gewisse Flexibilität drin. Die Frage, die man sich aber da vielleicht immer stellen muss, ist, wann ist dann vielleicht doch eine Wildschleife sinnvoller?

Persönliche Meinung, eine Vorschleife ist immer dann sinnvoll, wenn ich zum Beispiel einen bestimmten Wertepereich abdecken will. Ja, hier jetzt ganz konkret 1 bis 50. Ja, und ich eben alle drei Sachen sozusagen hier zusammengehören.

Ja, ich sage von 1 bis 50 jedes Element oder jede Zahl zwischen 1 und 50. Ganz, ganz klassischer Fall. In fast fast allen Fällen der Vorschleife schreibt man genauso was hin.

Es gibt noch andere Sachen, es gibt noch andere Möglichkeiten, wollte ich hier einmal erwähnt haben, ist aber jetzt nicht unbedingt das, was man wirklich aktiv zum Programmieren immer im Hinterkopf haben muss. Okay, kurzes knappes Video zur Vorschleife. Wie gesagt, als Alternative zur Wildschleife. Die Wildschleife geht sozusagen immer. Die Vorschleife kann ich dann verwenden oder ist sinnvoll dann zu verwenden, wenn ich bestimmte Wertepereiche abdecken möchte, so wie hier die Zahlen zwischen 1 und 50.



do-while-Schleife

Weiter geht es mit Grundlagen der Programmierung. Heute ist Thema sind der Kontrollstrukturen. Ganz konkret Schleifen haben wir gerade am Wickel. Zwei hatten wir uns schon angeguckt. While und For und jetzt wollen wir das ganze Thema Schleifen abschließen mit der dritten Schleife, mit der Dualschleife.

Auch hier schauen wir uns an, wie ist die Dualschleife aufgebaut, wann verwendig sind vollerweise die Dualschleife und auch hier habe ich wieder so ein kleines Struktogramm mitgebracht. Was relativ ähnlich aussieht zu den beiden Vorherrigen, also zu dem von der For bzw. von der While-Schleife. Wir sehen aber der Unterschied ist, dass die Bedingung irgendwie nachfolgend ist. Also das heißt, dass die Bedingung quasi erst geprüft wird, nachdem das erste Mal der Schleifenblock durchlaufen worden ist, nachdem der Code hier in dem Schleifenblock verarbeitet worden ist, zum ersten Mal wird geprüft, aha muss ich jetzt die Schleife erneut starten oder nicht. Das eben automatisch dafür führt, dass dazu führt, dass mindestens einmal der Code hier oben durchlaufen wird. Wir schauen uns das ganze mal an, ein Beispiel wieder an. Und was ich hier machen würde mit euch, wäre so eine User-Eingabe, also ganz, ganz einfaches Beispiel.

Man kann sich jetzt denken, dass man das noch irgendwie beliebig ausbauen könnte. Aber wir sagen, wenn eine bestimmte User-Eingabe Q ist, Q steht für Quit, dann wollen wir aus der Schleife raus, aber bis dahin wollen wir quasi den User-Input annehmen und für unser einfaches Beispiel erst mal nur ausgeben. Ich bereite das hier mal ohne Schleife vor, dass wir sagen, String-Input und jetzt könnten wir hier sowas sagen, wie System Out Print, ja ich habe hier nicht dieses Print LN damit eben nicht eine Zeit umgebrochen wird und ich dann hier, wenn ich sage, Input ist gleich Scanner.nextline, damit dann hier eben der Input quasi entgegengenommen wird und das für mich so aussieht, das würde ich direkt nach dieser Ausgabe hier weiter schreiben. Ich gebe das dann hier nochmal auf der Konsole aus. Was eingegeben worden ist System Out Print LN, dann einfach hier Input was und dann den Wert, der eingegeben worden ist. Ich führ das ganze mal aus, scheint zu funktionieren, ja ich kann hier irgendwas eingeben und bekommt es danach auch ausgegeben.

Super. Jetzt wollen wir es aber ja so machen, dass wir so lange was eingeben wollen bis Q eingegeben wird. Sobald Q eingegeben worden ist, soll quasi die Schleife abgebrochen werden oder das Programm, aber bis dahin wollen wir irgendwie irgendwie den Input entgegennehmen und ausgeben. Dafür nehmen wir die Dual Schleife, wenig überraschend und die Synthax ist eigentlich recht einfach. Wir sagen, du haben dann unsere geschweiften Klammern, hier rein kommt dann der eigentliche Code, also der eigentliche Schleifenblock, Schleifenblock Und unser While steht hier unten, ja wieder mit runden Klammern, grundgenehm eine ähnliche Synthesie, auch bei der eigentlichen Wildschleife. Das Statement ist danach zu Ende, deswegen kommt hier noch so ein Semikolon dahinter. Und wir schreiben eben hier, wird auch im Code ersichtlich, unter den Schleifenblock unsere Bedingung. Unsere Bedingung hatten wir ja gesagt, ist solange nicht Q eingegeben worden ist, also sprich Ausrufezeichen, input.equalsQ, ja input.equalsQ würde heißen, es wurde Q eingegeben und ich drehe das Ganze hier um. Solange nicht Q eingegeben wird, soll die Schleife laufen. Und der Code, den wir hier reinpacken, ist ja letzten Endes genau das hier. Ich kopiere das jetzt einfach mal hier runter beziehungsweise möchte das oben eigentlich auch direkt löschen, so dass wir eben ja unseren input Eingabe beziehungsweise auch die Ausgabe in diesen, in diese Wildschleife gepackt haben. Ich speichere das Ganze mal, führte das Ganze mal wieder aus. Und es sieht erstmal genau gleich aus, sobald ich jetzt hier irgendwas eingebe, kriege ich es wieder ausgegeben und ich werde eben nochmal aufgefordert, nochmal input zu geben, könnte ich jetzt beliebig weitermachen. Spannend ist natürlich was passiert, wenn ich Q eingebe, wenn ich Q eingebe, sehen wir, das Programm wurde beschlossen, also ich werde nicht mehr nach neuem input gefragt. Was eben daran liegt, dass diese Bedingung hier unten dann nicht mehr erfüllt ist. Der input war Q, dementsprechend ist dieser Ausdruck hier false und ja die Schleifenbedingung ist nicht mehr gültig.

Warum ist jetzt hier eine Wildschleife im Vergleich zu einer Wildschleife geeignet? Wir wollen ja mindestens einmal input. Also das ist schon mal die erste Faustregel, sobald ich wirklich weiß, ich will mindestens einmal das irgendeine bestimmte Aktion erfolgt, also in unserem Fall, dass mindestens einmal input entgegengenommen wird, dann eignet sich die Wildschleife. Auf der anderen Seite ist es so, wir können es ja mal testen, wenn ich jetzt hier versuchen würde, dasselbe mit einer Wildschleife zu machen, das droht jetzt eine Endloschleife zu werden, wenn ich nicht wüsste, dass der Compiler da eh gleich was dagegen sagt. Wenn ich jetzt hier sagen würde, Wild input das sind equal Q und ich führ das Ganze aus, dann sehe ich, diese Konsole ist jetzt noch vom letzten Mal, ja, hier gibt es einen kleinen Fehler, weil er eben sagt, wir haben unseren Input noch gar nicht initialisiert. Also ich müsste jetzt hier künstlich irgendwie von Anfang an irgendeinen Wert festgeben, den ich dann hier unten sowieso wieder überschreiben würde, damit ich überhaupt eine Wildschleife nutzen könnte und das ist hier natürlich nicht sinnvoll, sondern wir wissen ja, was wir machen, wir wissen, wir wollen mindestens einmal Userinput eingeben, dementsprechend können wir hier diese Dualschleife verwenden, wo klar ist, es wird auf jeden Fall Input initialisiert, es wird ja auf jeden Fall ein Wert zugewiesen und dementsprechend ist hier unten auch klar, es gibt eben schon einen Wert und der kann dann geprüft werden. Dementsprechend eignet sich hier die Dualschleife und unterscheidet sich eben stark von while und for insofern, dass die Bedingung nachfolgend geprüft wird. Das ist eigentlich der große Unterschied. Okay, so viel dazu, dann würde ich sagen, machen wir gleich weiter mit Fallunterscheidungen und mit Abzweigungen.



Verzweigungen

Weiter geht es mit Kontrollstrukturen in Java und wir hatten uns ja schon Schleifen angeguckt in den letzten drei Videos, was wir uns jetzt ansehen wollen, sind Verzweigungen in Java, sprich wie wir mithilfe von if oder else eben abhängig von der bestimmten Bedingung Code ausführen oder alternativ anderen Code ausführen. Wir gucken uns dabei dann auch an wie wir solche Bedingungen vielleicht sogar mehrfach prüfen können oder an das mehrere Bedingungen prüfen können, beziehungsweise wie wir if und else verschachteln können. Ich habe auch hier wieder ein kleines Struktogramm dabei, ja das ist jetzt ein klassisches Beispiel, wir haben eine Bedingung und wenn die Bedingung eben erfüllt ist, dann soll ein Codeblock ausgeführt werden, wenn die Bedingung nicht erfüllt ist, dann wird eben alternativ anderer Codeblock ausgeführt.

Ja, wenn man jetzt überlegt, ich glaube das Beispiel war auch mal in so einer Einstiegsfolie irgendwo drauf, wir haben die Bedingung, die Ampel ist rot, wenn die Bedingung erfüllt ist, dann ist eben in dem Block, was zu tun ist, stehen bleiben und auf der anderen Seite, wenn die Bedingung nicht erfüllt ist, also wenn die Ampel nicht rot ist, sprich grün, dann würde es heißen, ich darf über die Straße gehen, meinetwegen. Ich habe auch hier wieder einfach ein Beispiel dabei, mit dem wir uns das mal ansehen können, beziehungsweise gleich mehrere und eine ganz klassische Sache, da verbinde ich jetzt auch schon mal so ein bisschen die Schleifen, die wir vorhin in den vorherigen Videos kennengelernt haben mit den Verzweigungen, ist, wenn wir zum Beispiel eine Vorschleife haben, ja und wir sagen, wir wollen uns einfach mal die Zahlen zwischen 1 und 10, also hier, alles angefangen mit 1, solange dieses i kleiner ist als 11, sprich die letzte Zahl ist die 10 und hier muss ich noch eins hochzellen. Für diesen Zahlenraum zwischen 1 und 10 wollen wir uns jetzt einfach angucken, welche ist gerade oder welches ungerade und wir machen es einfach so, dass wir nur die geraden Zahlen uns anzeigen lassen wollen. In dem Fall würde ich sagen, if und hier in Runde Klammern schreibe ich dann meine Bedingung, kennt man auch wieder, kann wieder geschweifte Klammern setzen und danach kommt der eigentliche Code, der dann ausgeführt werden soll, wenn die Bedingung eben erfüllt ist, ja, wenn i durch 2 teilbar ist, durch 2 teilbar ist ja nichts anderes als Modulo 2 gleich 0, dann möchte ich eben System Out Print Line von i, wenn ich das jetzt ausführe, müsste ich genau nur die geraden Zahlen zwischen 1 und 10 angezeigt bekommen.

Super, wenn ich auf der anderen Seite sage, ja also hier wäre jetzt quasi, wenn ich nochmal aufs Schutogramm zurück springe, gar kein Falls dabei bzw. gar kein Block dabei, der ausgeführt wird, wenn diese Bedingung hier Falls ist, sobald ich jetzt aber sage, na ja, im anderen Fall möchte ich was anderes machen, nämlich dann möchte ich ausgeben System Out Print Line i und dann ist ungerade, ja, dann würde jetzt eben entsprechend für die, das ist im Ecolon vergessen, Klassiker, dann würde entsprechend für die anderen Zahlen hier ausgegeben werden, 3 ist ungerade, 5 ist ungerade, 1 ist ungerade und so weiter und so fort, ja, das heißt, wenn diese Bedingung hier erfüllt ist, dann wird dieser Block hier durchlaufen, wenn die Bedingung nicht erfüllt ist, finden wir uns hier in diesem Els, ja bei dem Els gibt es natürlich keine Bedingung mehr, ja, sondern dieses Rundenklammern mit einer Bedingung drin sind nur bei dem if, das Els ist einfach der andere Fall, also sobald hier Falls rauskommt, sind wir in diesem Block. Okay, es gibt noch ein anderes Beispiel, was wir uns angesehen hatten bei der Einstiegs, bei dem Einstiegsvideo, was ein bisschen motivieren sollte zu dem Thema, nämlich dieses System von Noten. Also wir haben eine Klausurnote und die Klausurnote ist meinetwegen 1,3 und wir hatten gesagt, ja, wir können hier mit diesem Turnery-Operator schon erste kleine Sachen machen, so was wie eine Ausgabe hat bestanden oder hat nicht bestanden, aber vielleicht gibt es sehr viel mehr, mehrere Methoden, die irgendwie aufgerufen werden müssen oder sonst was, also ein bisschen komplexer, abhängig davon, ob man bestanden hat oder nicht. Ich würde das jetzt hier mal andeuten, dass wir einfach zwei Methoden formulieren, ja, die einfach mal so beispiellhaft dafür stehen, wenn man bestanden hat oder nicht, ich schreibe hier, hat bestanden, ich kopiere mir die Methode mal und sage hier nicht bestanden und dann halt nicht bestanden. Ja, man kann sich ja denken, dass hier noch ganz, ganz viel anderer Kram irgendwie angestoßen werden könnte für unser Minimalbeispiel will ich es aber erstmal so einfach halten wie möglich und jetzt eben darauf hinaus, dass wir hier so ein Fals machen können, was dann eben eine von den beiden Methoden aufruft, abhängig davon, welche Note geschrieben worden ist. Sieht ganz ähnlich aus wie da oben, ich würde sagen, wenn die Note kleiner ist als 5, sprich irgendwas zwischen 1,0 und 4,0, dann möchte ich die Methode bestanden aufrufen und ansonsten hoffe ich bitte die Methode nicht bestanden auf.

Ja, ich speichere das Ganze mal für das Ganze mal aus und würde jetzt hier sehen, okay, es ist jetzt blöd mit den beiden Beispielen, aber das ist der Output quasi zu dem, was wir gerade gemacht haben. Mit der Note 1,3 hätte ich eben entsprechend bestanden, wenn ich jetzt hier alternativ 5,0 hinschreibe und das Ganze ausführ, würde ich eben sehen, hat nicht bestanden, weil der Code eben ausgeführt wird, abhängig von dieser Bedingung. Wenn die Note kleiner ist als 5, wird gesagt bestanden, ansonsten wird gesagt nicht bestanden, bzw. wird der Code ausgeführt oder aufgerufen, in dem Fall die Methode. Okay, jetzt könnten wir das Beispiel ja noch mal ein bisschen weiterspinnen. Wir könnten sagen, ich ändere mal die Note wieder auf 1,3 und wir sagen, wenn jemand mit einer 1 bestanden hat, dann soll irgendwas Besonderes ausgegeben werden.

Wir könnten jetzt hier zum Beispiel sagen, wenn die Note kleiner ist als 5 und wenn die Note dann unter der Bedingung, dass sie kleiner ist als 5, auch noch mal kleiner ist als kleiner gleich, 1,3 könnte man sagen. Dann möchte ich, mache ich hier einfach mal ein System Outprint Line, einen Sonderfall, keine Ahnung, Katolation. Das ist den Glückwunsch. Speichern ausführen, ich habe hier oben die Note wieder zu einer 1,3 geändert.

In dem Fall wäre es so, dass wir so ein If verschachtelt hätten quasi. Also wir prüfen einmal, ob die Note kleiner ist als 5 und wenn ja, wird auch hier nochmal geprüft, ob wir quasi gratulieren können oder nicht. Und in beiden Fällen, also egal ob gratuliert worden ist oder nicht, habe ich ja bestanden, das heißt diese Methode hier wird trotzdem aufgerufen, aber ansonsten, wenn die Note kleiner 5 ist, dann eben weiter hin. Habe ich nicht bestanden und das wird die entsprechende Methode dafür aufgerufen.

Die zweite Sache, die ich dazu noch zeigen wollte, ist das Else If. Und zwar kann es ja sein, dass ich mir in so einem Fall hier sage, okay, wenn die Note kleiner ist als 5, dann ist egal ob gratuliert wird oder nicht, es wird bestanden. Wenn ich jetzt aber andere Fälle habe, wo ich jetzt zum Beispiel sage, ich mache eine extra Methode, Private Static Void, mit Auszeichnungen bestanden und mache auch wieder nur so ein einfaches System Outprint Line, hat, schreib mal mit Auszeichnungen bestanden, dann wäre es ja so, dass ich hier sagen würde, okay, wenn die Note eben kleiner gleich 1,3 ist, dann würde ich vielleicht die Methode aufrufen mit Auszeichnungen bestanden und ansonsten würde ich sagen, hoffe ich die Methode für bestanden. Es ist jetzt hier ein bisschen verschachtelt, das ist absichtlich ein bisschen unübersichtlich, weil ich gleich mich darauf hinarbeiten will, dass es dafür auch eine saubere, kleinere, schlankere Möglichkeit gibt und zwar das sogenannte Else If.

Ich könnte jetzt hier nämlich sagen, wenn die Note kleiner ist oder kleiner gleich, kleiner gleich 1,3 ist, dann möchte ich bitte die Methode, ich gucke mir das mal mit Auszeichnungen bestanden aufrufen und wenn nicht, aber die Note ist kleiner als 5, sprich ich habe trotzdem bestanden, dann wird die Methode bestanden aufgerufen und ansonsten, sprich in unserem Fall, wenn die Note eben praktisch nur ne 5 ist, ja, könnte theoretisch jede andere Zahl sein, die größer ist als 5, dann wird die Methode nicht bestanden aufgerufen. Also ist der Code, der macht genau dasselbe wie hier oben, ist aber noch mal ein bisschen schlanker, sauberer, weil wir eben nicht If und Else verschachteln. In dem Moment, wo ich merke, okay, ich habe hier so eine Fallunterscheidung, in der Fallunterscheidung, ohne dass sich quasi alle Noten, die besser sind als 5, irgendein Teil der Logik so richtig teilen. In dem Moment kann ich oft auf so ein Else If hinaus, das heißt ich habe hier einfach noch eine zusätzliche Prüfung, die unternommen wird und wenn jetzt, wie gesagt, die Note besser ist oder kleiner gleich 1,3, dann habe ich mit Auszeichnung bestanden, sonst wenn ich irgendwas besseres als ne 5 geschrieben habe, habe ich bestanden und ansonsten eben nicht bestanden. Was man hier vielleicht noch erwähnen müsste, was ganz wichtig ist, wenn ich das natürlich umdrehen würde, also hier quasi erstmal prüfen würde, ist die Note kleiner als 5 und danach ist die Note kleiner gleich 1,3, dann würde das nicht so funktionieren, wie ich mir das erhoffe, weil in dem Moment, wo ich hier oben natürlich prüfe, ist die Note kleiner als 5, wird der entsprechende Block hier ausgeführt, wenn ich hier oben dann auf eine kleinere Zahl prüfe, wird er quasi nie zu diesem Block hinkommen. Ich speichere das Ganze auch mal ab und möchte es einmal auf der Konsole zeigen. Wir haben hier eben genau 2x denselben Output, wenn ich jetzt aber die Noten ändern würde, also das ist jetzt doppeln mich hier stark, aber schreife hier auch mal ran, Vorsicht, nicht Bedingungen tauschen, kommt natürlich darauf an, aber jetzt in dem konkreten Fall möchte ich zum Beispiel nicht das so machen, dass ich hier sage Note kleiner als 5 und hier Note kleiner gleich 1,3, weil in dem Moment, ja, ah, okay, jetzt habe ich nur die Zahl geändert, aber noch nicht die eigentliche Sache, die dann passieren soll, das müsste ich natürlich entsprechend auch noch mit ändern. So, wenn ich jetzt den Code ausführe, dann wäre es so, diese Bedingung hier ist ja schon erfüllt, auch wenn ich eine 1,3 habe und dementsprechend wird dieser Block hier ausgeführt, wo die Methode bestanden aufgerufen wird, hier komme ich aber gar nicht erst hin, weil natürlich ist meine Note kleiner gleich 1,3, aber dadurch, dass diese Bedingung hier ja schon erfüllt worden ist, kommen wir eben nicht mehr zu der Prüfung darunter, sondern dieses If hat True ergeben, dementsprechend komme ich in den Codeblock und Java ist sozusagen glücklich und kümmert sich gar nicht mehr drum, was ich hier unten hingeschrieben habe. Deswegen hier Vorsicht, ja, wenn man so ein Else If verwendet, dass man guckt, dass die Bedingungen eben entsprechend auch in der richtigen Reihenfolge sind. Okay, das wäre in kürze alles, was es zu Verzweigungen oder zu Fels zu erzählen gibt fürs Erste.



Fallunterscheidungen

Wir machen weiter mit Kontrollstrukturen in Java. Wir hatten uns schon Schleifen angeguckt.

Wir hatten uns auch schon F &Ls angeguckt und jetzt geht es eben um Fallunterscheidungen nochmal, die wir in Java mit Switchcase abbilden. Wir gucken uns an, wie das genau genutzt wird. Da gibt es zwei Möglichkeiten eigentlich. Es gibt sozusagen die alte traditionelle Variante zu schreiben und auch eine neue Syntax, die wir uns beide ansehen werden. Ganz am Ende so als kleinen Bonus gucken wir uns auch an, wie wir mit Switchcase direkt Werte zuweisen können. Ich zeige da aber auch noch mal eine Alternative, weil diese Syntax schon noch mal deutlich anders sage ich mal ist, als das, was wir bisher gemacht haben. Und jetzt auch nicht unbedingt verlangt wird, dass das alle dann ab sofort drauf haben, wichtig ist, Switchcase zu kennen. Eine von den beiden Syntax Varianten sicher anwenden zu können bei Bedarf. Aber dieses Werte zuweisen ist am Ende noch mal so ein kleiner Bonus.

Okay, wir gucken uns zuerst das Struktogramm an. Beim Switchcase gehen wir davon aus, wir haben jetzt hier an dem Beispiel irgendein Nummer, die dann entsprechend geprüft wird und sobald Fall 1 eintritt, ja dann wird Fall 1 abgearbeitet, Fall 2 dann wird der zweite Block abgearbeitet und per Default gibt es irgendwie noch mal ein extra Block der abgearbeitet. Insofern ein bisschen ähnlich zu dem if else, ja also zu dem, oder zu dem else if auch, was wir uns letztes mal angeguckt hatten. Da könnte ich ja auch sagen, wenn die Zahl 1 ist, dann mach das, wenn die Zahl 2 ist, dann mach das und ansonsten mach irgendwas anderes. Der Unterschied ist aber hier bei Switchcase, dass eben wirklich konkrete Fälle abgeprüft werden, während ich bei if oder else if ja die Möglichkeit habe, zum Beispiel auch zu sagen, wenn die Zahl kleiner ist als 1. Also das ist der Unterschied, ja wir haben hier exakte Fälle, während wir bei if else die Möglichkeit haben, zum Beispiel ja auch, keine Ahnung, eine Zahl ist größer als x oder jeglichen anderen Bullien da irgendwie reinzusetzen.

Das geht halt hier nicht, hier werden konkrete Fälle geprüft. Ich würde sagen, wir gucken uns das auch am besten mal direkt an einem Code Beispiel an. Ich hatte hier glaube ich dieses Geburtstags Beispiel ganz am Anfang, also in dem Einstiegsvideo erklärt und hier könnte man ja einfach sagen, keine Ahnung, wenn ich 18 geworden bin, dann wird zur Volljährigkeit gratuliert, Volljährigkeit. Wenn ich 16 bin, dann wird mir angeraten ein Bier zu trinken, zur Feier des Tages und ansonsten also default Fall, einfach nur alles Gute. Okay, könnte man wie gesagt auch schon mit if else abbilden.

Switchcase ist insofern eine Sache, die man nicht unbedingt verwenden muss, also es gibt zumindest die Alternative immer mit im if else. Trotzdem ist es wichtig, das einmal gesehen zu haben und das zeige ich jetzt einmal hier. Wir zur Vorbereitung nehmen einfach einen int age und ich sage jetzt einfach mal, man wurde gerade 17.

Das heißt, wir würden uns hier in diesem default Fall finden, nichts Besonderes in Anführungszeichen zu feiern, weder die Volljährigkeit noch die Möglichkeiten, wir zu trinken oder zumindest nicht zum ersten Mal. Und wir wollten das nicht mit if else machen, sondern mit switchcase und ich fange jetzt mal direkt an mit der neuen Sündags, die quasi sagen würde, was ist der Fall, die Fallnummer, wenn ich jetzt hier auf das Struktogramm nochmal zurück gehe, also der Wert, den ich mir wirklich angucke, switch age, dann habe ich hier geschweifte Klammern und gebe dann meine einzelnen Fälle an, also zum Beispiel case, 18, jetzt habe ich mich vertippt, case 18, dann soll ausgegeben werden System Out Print Line Volljährigkeit, wenn ich hier 100 Jahre tippen würde, dann würden die Videos länger gehen. Muss jetzt also so reichen, 16, sagen wir einfach Bier, ganz stumpf und ansonsten im default Fall, also wenn jetzt weder 18 noch 16, dann soll einfach ausgegeben werden System Out Print Line, dann geben wir aus alles Gute. So, okay, füllen wir das ganze mal aus, gucken wir uns mal an, was das ergibt.

Okay, ergibt natürlich alles Gute, wenn ich jetzt hier die Zahl ändere auf 16 meine Dwegen, würde ich entsprechend Bier ausgegeben bekommen. Super Sache, ja, das ist die neue switchcase-Logik, ist eigentlich relativ schlank und ich greife jetzt hier auch schon von, also auf eine Sache vor, die ich noch mal in einem extra Video behandeln will, und zwar das Setzen von Klammern, es ist jetzt hier so, dass wir immer genau ein Statement danach haben, ja, also zum Beispiel immer System Out Print Line, ja, auch wenn dann ein anderer Wert drin steht, das ist im Grunde genommen immer dasselbe, es könnte natürlich sein, dass ich eigentlich auch mehr machen wollen würde, dann habe ich die Möglichkeit, geschweifte Klammern zu setzen und dann in diesen geschweiften Klammern eben alles, was ich irgendwie vorhaben könnte, zum Beispiel könnten wir jetzt für diesen Default Fall noch sagen, keine Ahnung, einfach noch ein zweites System Out Print Line mit Default, was auch immer, ja, dann müsste ich hier natürlich die Zahl wieder ändern, 377 Jahre alt geworden, sehr realistisch, und würde jetzt aber hier sehen, ja, 377 ist natürlich Quatsch, aber 18 und 16 sind das ganz eindeutig nicht, dementsprechend finden wir uns hier in diesem Default Block und es werden eben zwei Sachen ausgegeben, sobald ich aber nur ein Statement habe, kann ich die Klammern weglassen. Wie gesagt, ein extra Video nochmal zum Thema Klammern folgt, ist nämlich häufig so ein Fehler, vielleicht ist es auch nicht verkehrt, selbst wenn ich nur ein Statement habe, auch bei dem Switch Case von Anfang an die Klammern zu setzen, einfach aus Übersichtlichkeitsgründen, aber man findet eben oft das hier, deswegen wollte ich es einmal gezeigt haben.

Ich gehe nochmal einen Schritt weiter und zeige hier, wie wir direkt mit der, also bin jetzt sozusagen in einer anderen Reihenfolge unterwegs, als in der Einstiegsfolie erzählt, ich zeige nämlich jetzt mal direkt, wie ich hiermit direkt Werte zuweisen kann, und würde sagen, anstatt einem System Out Print Line wollen wir einfach nur den Wert in einem String abspeichern, also Volljährigkeit, Bier oder einfach alles Gute, und dafür sage ich jetzt einfach String STR, meine Dwegen, ist gleich, was auch immer hier rauskommt. Ich nehme jetzt hier mal wieder diese Klammern weg, weil ich auch hier dann was zeigen will, wieder alternativ, wie das mit Klammern aussieht. Ja, so ist es natürlich viel einfacher. Ich schreibe einfach den jeweiligen String, der mir für das jeweilige, für den jeweiligen Fall zurückgegeben werden soll, hier sage ich alles Gute, und so weit so gut. Hier müsste man jetzt aufpassen, das ist ein bisschen tricky. In dem Moment, wo ich hier eine Wertezuweisung mache, brauche ich hier wieder auch das demikolamen am Ende des Statements. Wenn ich das weglassen würde, würde mich Java darauf hinweisen. Hier steht noch ein bisschen im Weg. Hier steht einfach ein Semikolon wird erwartet. Das ist davor nicht so.

Wie gesagt, dieser Sündtags ist noch mal ein bisschen anders als alles, was wir bis jetzt so gemacht haben. Ich wollte es aber vollständig halber zeigen. Und jetzt habe ich das Semikolon ergänzt. Jetzt würde ich auch nochmal hier in einem System Outprint Line ausgeben, was wir zugewiesen haben. Wir sind bei der 377 weiterhin.

Dementsprechend würden wir hier alles Gute in die Variable str abspeichern und die dann hier auch ausgeben. Wenn ich jetzt hier vielleicht wieder 18 hinschreibe, dann den ganzen Code ausführe, dann würde ich Volljährigkeit angezeigt bekommen. Hier zeige ich auch noch eine Kleinigkeit. Und zwar habe ich auch hier die Möglichkeit, Klammern zu verwenden, weil ich vielleicht nicht nur einen Wert habe, der da einfach zurückgegeben werden kann, sondern weil es vielleicht doch noch mal ein bisschen umständlicher ist und ich vielleicht ein bisschen mehr machen muss, vielleicht irgendwas berechnen muss. Zum Beispiel könnte ich jetzt sagen, statt einfach nur alles Gute möchte ich, was auch immer, nochmal einen Text da hinschreiben. Hier habe ich die Möglichkeit auch Klammern zu verwenden. Und jetzt muss ich aber ja irgendwie diesen Wert zurückgeben. Und dafür gibt es einen Schlüsselwort. Das heißt, yield. Das ist so ein bisschen wie das Return am Ende von der Methode.

Wie gesagt, ist eine neue Sache in Java, insofern vielleicht ein bisschen erschlagen, neue Sündtags, neue Worte, alles ganz anders. Wenn einem das gefällt, super kann man verwenden, ansonsten zwingt einem auch niemand dazu. Man kann alles, was man in Switchcase macht, auch mit Fls abdecken. Ansonsten, wenn in Switchcase mal schlanker ist, kann man ja trotzdem gucken, welche Sündtags man jetzt genau macht.

Die alte Sündtags stelle ich auch gleich noch mal vor. Okay, ich mache jetzt hier einfach mal ein System Outprint Line mit rein. Damit klar ist, dieser Code hier wird durchlaufen. Ich sage jetzt hier mal, man wird 22. Und in dem Moment würde default ausgegeben werden hier. Und das würde sozusagen in diesem Switchcase alles Gute zurückgegeben werden.

In Anführungszeichen ist natürlich nicht ganz eine Methode, aber funktioniert relativ ähnlich. Und hier entsprechend wäre mein String. Ja, alles Gute, sehr schön.

Okay, das wäre diese erweiterte Switchcase-Logik. Wie gesagt, direkt mit der Zuweisung. Ich will noch eine Kleinigkeit zeigen dazu, nämlich wenn ich jetzt hier direkt sagen würde, String-STR. Und ich weiß gar nicht, ob ich den hier initialisieren müsste. Ich möchte einfach nur darauf hinaus, dass ich hier natürlich trotzdem auch als den Code, der durchlaufen wird, wenn ein bestimmter Fall eintritt, auch direkt hier die Wertzuweisung machen könnte, wenn ich das will. Jetzt habe ich das dummerweise gelöscht. Voll Ehrigkeit. Alternativ hier String ist gleich Bier. Und hier String ist gleich alles Gute.

Ist nur eine Alternative, falls mir jetzt irgendwie diese Variante mit dem ist gleich und mit diesem gilt ein bisschen komisch vorkommt. Ja, dann ist das hier vielleicht nochmal ein bisschen vertrauter. Auch hier kann ich natürlich wieder nach belieben Geschweifelklammern setzen, was ich vorhin erzählt hatte.

Muss aber nicht mehr dieses Ziel schreiben, weil eben nicht mehr für dieses Switchcase sozusagen der Wert zugewiesen wird, sondern einfach als Teil des Switchcase, quasi als Teil des Codes, der ausgeführte Wende im bestimmter Fall eintritt. Ich einfach sage dann, weise doch bitte den Wert zu. Muss man vielleicht nochmal ein bisschen Ruhe drüber nachgucken und nochmal drüber schauen, um die Unterschiede nochmal genau zu sehen. Es sind aber insofern zwei Möglichkeiten und da gilt alle Wege für nach Rom. Was ich auch nochmal zeigen möchte bei der Gelegenheit, ist einfach die alte Switchcase-Logik. Die hat so ein bisschen ihre Tücken auch. Dementsprechend hat man dann irgendwann gesagt, okay, wir wollen das ändern, wir wollen diese neue Logik. Trotzdem funktioniert die alte natürlich noch weiterhin. Sieht erst mal recht ähnlich aus. Ich bleib bei dem Beispiel Switch und dann Age. Und dann haben wir irgendwie unsere Fälle. Und hier ist es jetzt so, dass wir nicht mit dieser Pfeilsyntax arbeiten, sondern mit Doppelpunkten und dann hier einfach aufpassen, ohne Klammern tatsächlich sagen.

Was passiert in den jeweiligen Fällen? Case 18, dann geben wir einfach aus Volljährigkeit. Und theoretisch könnte ich jetzt hier noch mehr machen. Case 16, dann hatten wir gesagt, geben wir aus Bier und dann hatten wir noch den Defaultfall. Default und hier sagen wir einfach alles Gute. Okay, hier sage ich jetzt mal alte Syntax und hier oben sage ich jetzt mal enhanced Switchcase. Ich führ das Ganze mal aus, damit klar ist, dass auch diese alte Syntax irgendwie funktioniert. Und wir sehen, Alter war 22, wir kriegen eben zweimal alles Gute ausgegeben. Jetzt gibt es aber ein Problem bei der alten Switchcase-Logik und die motiviert dann ein Video, was ich gleich nachsteuern werde. Nämlich ist es so, dass ich hier bei Switchcase, wenn ich zum Beispiel, nehmen wir mal die 18, hier als Alter 18 habe, er sozusagen hier einsteigt und Volljährigkeit ausgibt, aber auch gleichzeitig alles, was da drunter liegt.

Vorhin war die Zahl wieder 18, noch 16, dementsprechend ist er von Anfang an hier in das Default und man hat sozusagen nicht das Problem gesehen. Hier ist es aber so bei der alten Switchcase-Logik, ohne diese Pfeile, sondern mit diesen Doppelpunkten, dass wir eben hier einsteigen und alles, was darunter liegt, auch noch mit ausgeführt wird. Das führt uns dazu, dass wir eigentlich immer, wenn wir nicht explizit genau dieses einsteigen und weitermachen wollen, hier so ein Break setzen müssen. Dazu werde ich gleich noch ein extra Video hochladen und das nochmal genauer erklären.

Und in dem Moment, wo ich dieses Break hier habe, würde er auch mit der alten Logik nur Volljährigkeit ausgeben bzw. nach dem Fall Nummer 18 aufhören. Wie gesagt, Switchcase kann man im Grunde genommen auch mit FLs lösen. Auf der anderen Seite ist es vielleicht manchmal doch schlanker, Switchcase zu machen, so was hier sieht ja doch relativ schön aus, würde ich mal meinen. Ich habe jetzt zwei Möglichkeiten gestellt, wie man das schreiben kann. Hier unten die alte Syntax, oben die neue Syntax. Wir hatten uns hier auch gleich mal angeguckt, wie man quasi mitten im Switchcase Werte zuweisen kann. Das ist vielleicht ein bisschen erschlagen, ein bisschen viel zum Anfang.

Kann man sich angucken, ob man das mitnehmen will, ob man das im Reportage haben möchte oder sagt, man findet da einen anderen Weg. Wie gesagt, das hier zum Beispiel hat der letzten Ende das selbe Ergebnis. Das ist ja, dass wir hier oben eine Variable deklarieren und dann unten die Wertzuweisung machen, eben je nach Fall. Und eben diese Wertzuweisung sozusagen, der Code ist der ausgeführt wird. Zu den Klammern, die ich jetzt hier gesetzt habe und hier nicht hatte, ich werde jetzt etwas erzählen zu. Bzw. hier zu dem Break werde ich noch genau die letzten zwei Videos machen zum Thema Kontrollstruktur.



break und continue

Weiter geht es mit Kontrollstrukturen und eigentlich sind wir fertig.

Eigentlich haben wir alle Kontrollstrukturen als solche schon mal kennengelernt. Ich hatte im letzten Video aber mit diesem Break aufgehört im Kontext von Switchcase und wollte nochmal auf Break bzw. auf Continue eingehen bzw. wie wir damit Programmcode unterbrechen oder eben weiterführen können. Ich springe direkt zum Code und greife vielleicht nochmal dieses Beispiel auf von gerade eben mit dem Switchcase.

Das heißt wir hatten hier irgendwie gesagt, das war dieses Geburtstagsbeispiel, ja Switch oder erstmal int age ist 18 meinetwegen und Switch mit der traditionellen alten herkömmlichen syntax. Ja also Case mit den Doppelpunkten und dann sage ich hier System Out, Printline und dann sagen wir hier Volljährig. Ich schweige jetzt mal diesen zweiten Case den wir noch hatten. Ich sage jetzt hier einfach Default, System Out, Printline, alles gute und in dem Fall hier wo wir 18 sind würden beide Werte ausgegeben werden. Das ist jetzt hier vielleicht sogar noch halbwegs sinnvoll. Wenn ich jetzt aber hier sagen würde alles gute zum 18.

Dann würde es irgendwie wenig Sinn ergeben, ja aber warum soll ich da zweimal gratulieren und was ich eigentlich möchte wäre hier den Kontrollschluss zu unterbrechen. Also das hatten wir uns angeguckt, das ist im letzten Video auch schon drin am Ende, dass wir mit Switchcase, mit dieser veralteten syntax eben dafür sorgen müssen, dass er nicht bei der 18 einsteigt und dann alle Fälle sozusagen runterrattert ab dann, sondern dass in den meisten Fällen wir eigentlich sagen okay das soll halt genau das hier machen bzw. das hier machen.

Genau alles was ich hier hinschreibe, ich könnte theoretisch auch noch ein bisschen mehr machen, mache ich jetzt aber nicht und danach aber eben aufhören. Okay, das wäre jetzt ein Fall von dem Break, ein anderes Beispiel von Break wäre die Verwendung in Schleifen, dass wir nämlich damit auch eine Schleife unterbrechen können und zwar komplett also beenden können. Ich zeige das einmal, ja ich habe hier ein kleines Beispiel dabei, dass wir einfach sagen wir haben eine Vorschleife und wir sagen von int i ist gleich 0 bis i kleiner als 11, sprich von 0 bis 10 und wir sagen i++ ja also von 0 bis 10 sollen Werte meinet wegen auf der Konsole ausgegeben werden System out, Print line i ich speicher das ganze für das ganze mal aus ja und wir sehen es werden diese zehn bzw. elf Zahlen ausgegeben und jetzt möchte ich einfach einmal zeigen wie break bzw. wie continue funktionieren wir fangen an mit break, ich sage jetzt hier falls die zahl mal sechs sein sollte wir wissen das wird irgendwann passieren falls die zahl mal sechs sein sollte wollen wir break, wir wollen quasi aus der schleife ausbrechen, ich speichere das mal ab und führ das aus, einfach um zu zeigen okay, dann würden eben alle zahlen von null bis fünf ausgegeben werden, weil in dem moment wo hier diese bittingung true ist, wo i6 ist, wird aus der schleife ausgebrochen, aus der kontrollstruktur, dementsprechend wird er weder das hier unten noch ausführen, noch mehrfach irgendwie über diesen code iterieren. Das wäre das eine beispiel, dann gibt es noch das continue und das würde ich jetzt einfach mal so machen, dass wir sagen wenn i modulo 2 gleich null ist, sprich wenn i gerade ist, dann wollen wir dann sagen wir continue und continue heißt nichts anderes als die aktuelle iteration wird sozusagen gestoppt, wir machen danach aber nahtlos weiter, das heißt wir würden jetzt in dem fall hier nicht mehr zu diesem system on print line kommen für die geraden zahlen, aber wir würden danach weiter machen, ja also wir fangen bei null an, null modulo 2 ist quasi null dementsprechend kommen wir hier in dieses continue, die aktuelle iteration wird abgebrochen, aber die schleife wird weiter geführt mit der nächsten iteration, ja in der nächsten iteration haben wir dann die 1, 1 ist weder gleich 6, noch ist 1 durch 2 teilbar, dementsprechend wird 1 auf der konsole ausgegeben und danach haben wir die 3, die 2, die 2, wird wieder nicht angezeigt, weil hier wir in dieses continue laufen und so weiter und so fort, bis wir eben dann bei der 6 angekommen sind und die schleife aus der schleife ausbrechenden anführendes zeichen, okay das hier ganz schnell als möglichkeit um noch mal ja noch ein bisschen einfluss sozusagen zu haben auf die kontroll strukturen, indem wir aus einer schleife ausbrechen können oder zumindest aus einer aktuellen iteration ausbrechen können und dann zu der schleife zur nächsten iteration wieder zurückkehren können, vielleicht auch hier noch mal der hinweis dieses break finden wir jetzt in schleifen oder können wir in schleifen verwenden oder in dem switchcase dieses continue hingegen können wir natürlich nur in schleifen verwenden, weil dafür brauchen wir irgendeine neue iteration mit der dann weiter gemacht werden kann, okay so viel dazu in kürze ja das ist jetzt ein minimal Beispiel und man könnte jetzt hier natürlich auch von vornherein sagen naja warum schreibst du mich hier sofort 6 hin, wenn das das ender der schleife sein soll, man kann sich aber vorstellen es mag vielleicht fälle geben wo man sagt okay wenn der und der fall eingesetzt ist was jetzt nicht unbedingt meine schleifenbedingung ist dann will ich aus der schleife ausbrechen, das ist jetzt hier wieder nur so ein minimal Beispiel



Kontrollstrukturen und geschweifte Klammern

Okay, letztes Thema zum großen Thema Kontrollstrukturen und zwar hatte ich schon mal angeteasert Kontrollstrukturen und geschweifte Klammern, also ein bisschen ein Herzens Thema, kleiner Bonus. Hatten wir uns schon mal so leicht angeguckt im Kontext von Switchcase, bzw. da habe ich gesagt, es wird noch ein extra Video geben und das kommt genau jetzt. Wir gucken uns an, in welchen Fällen ich geschweifte Klammern setzen kann bzw.

setzen muss. Bis jetzt habe ich immer irgendwie geschweifte Klammern gesetzt, da werfen wir aber noch mal einen Blick drauf bzw. gucken wir dann ein bisschen allgemeiner, welche Formatierung vielleicht sinnvoll ist, um einfach den Überblick über sein Code zu behalten. Ich spring hier direkt in den Code und gebe einfach mal ein kleines Beispiel, was jetzt nicht mehr großartig überraschend sein sollte. Wir haben einfach eine Vorschleife und wollen die Zahlen zwischen, in dem Fall jetzt 1 und 9 irgendwie betrachten, bleiben wir bei dem Beispiel und sagen System Out, Print Line, i, ich speichere das Ganze ab, führ das Ganze aus und es wird wenig überraschend jede Zahl zwischen 0 und 9 oder jede ganze Zahl zwischen 0 und 9 ausgegeben.

Super. Hier hatte ich es jetzt immer so gemacht, dass ich geschweifte Klammern gesetzt habe. Das würde ich auch ziemlich stark empfehlen. Strenge genommen müsste ich die aber in dem konkreten Beispiel nicht setzen, sondern könnte das genauso auch hinschreiben, den Code laufen lassen und würde zum selben Ergebnis kommen.

Das liegt daran, dass geschweifte Klammern eigentlich immer nur aussagen, was ist quasi der Scope von dem Code, der zumal der Kontrollstruktur gehört. Also was ist jetzt hier konkret mein Schleifenbody? Das besteht aus genau einem Statement. Sobald ich jetzt hier ein zweites Statement hinzufüge, würde ich schon anders sehen.

Aber so perne ich eben wirklich nur ein Statement habe, also in unserem Fall dieses System Out, Print Line, dann kann ich auf geschweifte Klammern verzichten. Die Frage ist, ob das zu empfehlen ist. Ja, es ist wichtig, das mal gesehen zu haben.

Vielleicht wird auf Stack Overflow eine Antwort zu sehen sein oder von Chatchi Pt irgendwas kommen, wo mal auf geschweifte Klammern verzichtet wird. Und es ist eben wichtig, das dann dadurch mal gesehen zu haben. Aber die Frage ist, wie sinnvoll das ist zur Lesbarkeit. Wenn ich jetzt nämlich hier zum Beispiel die geschweiften Klammern sind, noch da, aber System Out, Print Line, keine Ahnung, irgendwas, ja, irgendwas, was. Ausgebe, dann hätte ich jetzt, ah, ein bisschen mit Code noch vergessen, dann hätte ich jetzt hier, jeweils die Zahl und irgendwas ausgegeben. Sobald ich jetzt aber sage, ach, die geschweiften Klammern stören mich irgendwie viel zu viel Code, ich würde das alles noch kleiner machen und zwei Zeichen sparen, dann würde ich dieses irgendwas eben nur am Ende angezeigt bekommen. Das ist jetzt hier ganz trügerisch natürlich, weil das durch die Einrückungen auch noch so aussieht, als würde das quasi zueinander gehören. Man kann sich das aber so denken.

Einrückungen sind sowieso eine Sache, die in Java ziemlich wichtig sind, also einfach gute Formatierung, um den Überblick zu behalten. Das heißt, selbst wenn ich auf geschweifte Klammern verzichte oder vor allem wenn ich auf geschweifte Klammern verzichte, sollte ich darauf achten, dass die Einrückungen mir das lesen dann immerhin ein bisschen erleichtern. Ansonsten wird es ganz schön unübersichtlich.

Deswegen ist die Empfehlung, wie gesagt, geschweifte Klammern zu setzen. Ich leg jetzt hier nochmal einen drauf und packe unter diese Vorschleife, wie hatte mir jetzt hier selber die Formatierung so ein bisschen zerschossen, unter diese Vorschleife möchte ich jetzt noch ein, also nicht System Outprint Line das einzige Statement haben, sondern tatsächlich so ein if. Und dann sage ich, wenn i modulo 2 gleich 0 ist, meinetwegen, nur dann soll dieses System Outprint Line ausgegeben werden. Ich nehme dieses komische irgendwas hier unten mal raus, speichert das ganze mal ab, führt das ganze mal aus.

Wir sehen dieses if ist ein Statement, zudem wiederum dieses eines Statement gehört. Wenn ich das jetzt richtig einrücken würde, würde es so aussehen, dass hier es grundsätzlich möglich in Java, aber auch hier nochmal nicht unbedingt so empfehlen. Was ich empfehlen kann oder was in meinen Augen okay ist, weil man dann nicht so einfach durcheinander kommt ist, wenn man jetzt so ein einfaches if hat zu sagen, ich schreibe es dann in dieselbe Zeile. Das ist so, wie ich das auch oft mache, wenn man dann sagt, okay, sobald es in derselben Zeile steht, ist es schon klar, dass es sich aufeinander bezieht. Hier lasse ich jetzt dann die Klammern weg, das ist in Ordnung. Aber ansonsten habe ich jetzt auch hier gerade für die Vorschleife nochmal gemacht, kann ich immer nur empfehlen geschweifte Klammern zu setzen, weil so eben klar ist, welcher Code wozu gehört. Die automatischen Einrückungen sind sowieso sinnvoll, aber insbesondere wenn ich ohne geschweifte Klammern arbeite, quasi das A und O, um überhaupt noch was im Code lesen zu können. Deswegen hier dieses Herzensthema mit einem Stolperstein, wo viele vielleicht am Anfang nochmal reinlaufen, dass man eine Klammer vergisst und dann geht es, aber irgendwie geht es dann doch nicht ganz so, wie man sich das hat vorgestellt, weil man vielleicht sagt, okay, die weiß ich nicht, der Code in meinem Schleifenbody macht irgendwie nur die Hälfte, weil eben nur das erste Statement berücksichtigt wird und die anderen Statements nicht mehr. Also haben wir uns hier angeguckt, geschweifte Klammern, manchmal optional, immer empfehlenswert eigentlich und sobald ich wirklich sage bei so einem if zum Beispiel, ich verzichte meinetwegen auf geschweifte Klammern mehr meine klare Empfehlung, das dann dafür aber auch in eine Zeile zu schreiben, damit wirklich klar ist, das bezieht sich aufeinander und damit ich jetzt auch nicht in Versuchung komme, weil wenn ich das jetzt hier so stehen hätte, dass ich sage, ach ja, wenn i modulo 2 gleich 0 ist, dann soll auch noch irgendwas passieren, aber das hier wäre ja quasi nicht mehr das erste Statement ohne geschweifte Klammern, würde das also quasi ignoriert werden in Anführungszeichen bzw. einfach unabhängig von dieser Bedingung hier, unabhängig von diesem if oder außerhalb von diesem if ausgeführt werden. Okay, so viel dazu, ich hoffe, es ist verständlich, was gemeint ist damit, dass wir Leserlichkeit ja warn wollen bei der Sache und Fehler an Völligkeit vermeiden wollen durch solchen Kleinkramen, trotzdem war es mir wichtig, das einmal gesehen zu haben.