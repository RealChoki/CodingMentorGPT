
Einstieg in die Objektorientierung: Klassen und Objekte

Hallo zusammen. Wir steigen heute ein in das Thema objektorientierte Programmierung oder Objektorientierung. Gucken uns dabei Klassen und Objekte an. Dieses Thema, da hatten wir von Anfang an zwar gesagt Java ist eine objektorientierte Programmiersprache, haben dann aber eigentlich konsequenten im Bogen drum gemacht.

Heute ist es also soweit und wir sehen uns an, was sind Klassen und Objekte, bzw. wo liegen hier die Unterschiede, welche Merkmale hat eine Klasse und verantworten damit die große Frage, was ist überhaupt unter objektorientierter Programmierung zu verstehen. Was mir ganz wichtig ist, was in dem Video jetzt auch versucht wird, ist ein bisschen die Brücke zu schlagen zum Modul GSE, Grundlagen Software Engineering, GSE und Grundlagen der Programmierung gehen natürlich Hand in Hand miteinander und wo bzw. warum, gucken wir uns hier auch direkt an. Ich habe hier jetzt auch gar kein Code dabei, das kommt dann in den kommenden Videos bzw. in den kommenden Wochen, in den Vorlesungen, Tutorien und so weiter und so fort. Hier jetzt wirklich erstmal nur ein paar Folien, um so einen ganz kleinen Einstieg in das Thema zu bieten und der Code dann demnächst bzw.

in den kommenden Videos. Ich fange an mit einer bescheidenen Frage und zwar, wie lässt sich die Welt abbilden? Schwierig, die Welt ist komplex, die Welt ist ziemlich groß, wir werden also nicht ohne weiteres die Welt abbilden können. Was wir aber machen können, ist für irgendeinen Kontext, der uns interessiert, zu versuchen, das Ganze zu abstrahieren, um eben ein einfaches, in Anführungszeichen oder relativ einfaches Modell zu bilden. Billiges Beispiel hier, wir haben Menschen und ein Mensch besitzt ein Fahrrad bzw. ein Mensch liest ein Buch. Ganz eindeutig ist das nur ein Ausschnitt der Realität.

Ein Mensch kann zum Beispiel auch dieses spannende Video hier sehen oder, keine Ahnung, ein Brötchen beim Bäcker kaufen, schlag mich tot, alles Mögliche. Hier also nur ein Ausschnitt der Realität, der irgendeine bestimmte Fragestellung beantworten soll. Wir brechen es also runter auf irgendwelche Dinge, die irgendwie miteinander interagieren bzw.

irgendwie miteinander in Verbindung stehen. Menschen besitzen Fahrräder bzw. lesen Bücher, in dem konkreten Beispiel. Das ist im Grunde auch schon der Grundgedanke von objektorientierter Programmierung, nämlich sein Code genauso aufzubauen bzw. sein Programm genauso aufzubauen, wie die Welt da draußen aussieht. Wie das ganz genau aussieht, gucken wir uns direkt an bzw. in den kommenden Videos dann auch im Code.

Wären wir ein bisschen technischer. Wir hatten gesagt, es gibt irgendwelche Dinge in Anführungszeichen, die miteinander in Verbindung stehen. Wenn ich jetzt das erste Wort hier schon mal in den Mund nehmen möchte, nämlich Objekte, haben wir lauter Objekte, die irgendeine Beziehung zueinander haben. Und über Objekte kann ich immer ganz konkret sprechen. Ich könnte jetzt zum Beispiel sagen, das ist ein schöner Stuhl, eine blonde Person, ein blaues Auto und so weiter und sofort. Und damit meine ich nur diesen Stuhl, diese Person, dieses Auto. Es gibt weniger schöne Stühle oder Personen mit dunklen Haaren oder Autos, die eben nicht blau sind. Das sind aber eben andere Objekte.

Auf der anderen Seite kann ich oft auch Porschale Aussagen treffen über eine ganze Klasse, also allgemein über eine Klasse von Objekten. Zum Beispiel könnte ich sagen, Studierende sind immer fleißig, Computer machen immer was sie wollen oder auch die Bahn kommt immer zu spät, wie auch immer. Klingt erst mal noch alles ein bisschen abstrakt. Ich habe die KI befragt, um ein wunderschönes Beispiel hier rauszuziehen. Und zwar kam leider kein schöneres Bild bei raus, Studierende. Zwei Studierende, meine wegen an der HTW. Die Gemeinsamkeit ist, sie sind Studierende, allerdings wenn wir darauf gucken, die eine Person heißt Alice, Matrikennummer 1, 2, 3, 4, 5, 6 und ist 23 Jahre alt.

Auf der anderen Seite haben wir Bob und Bob ist 19 Jahre alt und hat eine andere Matrikennummer. Also die Ausprägungen von diesen Studierenden sind irgendwie ganz anders. Um wieder den Bogen zurückzuspannen zu Java. Eine Klasse in Java ist nichts anderes als ein benutzerdefinierter Datentyp bzw. ein Bauplan für so ein Projekt. Wir hatten gerade gesagt, wir haben Studierende und die hatten irgendwie beide Namen, auch wenn der unterschiedlich war, hatten beide Matrikennummer, hatten beide ein Alter und genau das würden wir in so einer Klasse festlegen, nämlich dass eine Studierende Person einen Namen, eine Matrikennummer usw. hat.

Also Attribute hat. Das heißt, welche Eigenschaften hat ein Objekt dieser Klasse? Auf der anderen Seite können wir auch definieren, was Objekte dieser Klasse tun können, also welche Operationen sie haben. Zum Beispiel könnte man jetzt sagen, Studierende können, was auch immer Bücher lesen, Kurse buchen, sich krank melden, keine Ahnung.

Alles mögliche. Ja, das sind Sachen, die die Person tun kann und das andere sind eben die Attribute, also die Eigenschaften, die eine Person hat. Auf der anderen Seite haben wir Objekte, ja das ist wieder das selbe schöne Bild von vorhin. Das heißt, die konkreten Instanzen einer Klasse. Wir haben Alice und Bob und Klarteilen, die beiden sich, die Tatsache, dass sie Studierende sind, aber ihre Ausprägungen sind eben ganz anders. Und was wir genutzt haben um solche Objekte, es fühlt sich immer komisch an über Menschen zu sprechen und trotzdem in Genre von Objekten zu reden. Aber wenn wir zwei Objekte Student erstellen, haben die halt ganz verschiedene Eigenschaften. Wenn wir zum Beispiel ein Objekt Alice erstellen würden, dann wäre der Name Alice, das Alter 23, Matricle Nummer 1, 2, 3, 4, 5, 6 und für Bob wäre es eben anders. Für Bob wären die Attribute Bob, Matricle Nummer 9, 8, 7, 6, 5, 4, irgendwas und Alter war 19 oder was wir gesagt hatten. Also hier haben wir ganz konkrete Ausprägungen mit ganz unterschiedlichen Charakteristiken. Und es gibt, wir hatten am Anfang bei der einfachen Fragestellung, wie können wir die Welt darstellen, gesehen, okay man kann das ganze visualisieren. Man kann Modelle irgendwie herstellen und eine ganz, ganz typische Sache in der Programmierung um den Zusammenhang von Klassen bzw.

die Struktur von Klassen irgendwie darzustellen, sind Klassendiagramme. Hier bin ich mir jetzt nicht sicher, ob das schon bekannt ist oder nicht. Entweder das wurde in GSE schon behandelt, dann ist das hier relativ langweilig oder es kommt noch in den kommenden Wochen. Das hier ist auf jeden Fall ein etablierter Weg, Grafik habe ich mir kopiert, habe ich mir jetzt nicht ausgedacht.

Wie man solche Klassen bzw. die Beziehungen zueinander darstellen kann, wie gesagt, in einem etablierten Format. Um dieses Beispiel hier vielleicht einmal anzuschauen gemeinsam, wir haben Kunden, ein Kunde hat beliebig viele Bankkunden bzw. ein Konto kann auch verschiedene Kunden haben, die irgendwie berechtigt sind darauf zuzugreifen. Ein Kunde kann wiederum sein ein Privat bzw. ein Geschäftskunde.

Und sowohl ein Privat bzw. ein Geschäftskunde hat genau eine Adresse und an einer Adresse wiederum könnten wir beliebig viele Privatkunden bzw. Geschäftskunden haben. Das ist jetzt eine Möglichkeit, das was wir uns in den kommenden Videos bzw. in den kommenden Wochen ansehen, Grafe startzustellen. Wenn ihr das in GSE schon gemacht habt, wisst ihr auf jeden Fall, was es damit auf sich hat, wenn nicht kommt das Zeit nach und damit hier die versprochene Brücke zu Grundlagen Software Engineering. Wie gesagt, das waren die versprochenen Folien ohne Code. Code gucken wir uns jetzt direkt an. Erster Einstieg in die Objektorientierung und in dem Sinne würde ich sagen, bis gleich beim Programmieren.



Aufbau von Klassen

weiter geht es mit dem Thema Objektorientierung und hier jetzt diesmal am Code gucken wir uns an wie Klassen aufgebaut sind. Wir hatten gesagt Klassen sind nichts anderes als definierte Datentypen in Java.

Das heißt wir schauen uns an wie wir die erstellen können und dann entsprechend wie das Ganze aussehen würde in Java. Noch mal ganz kurz zur Wiederholung. Wie gesagt Klassen benutzen definierte Datentypen sind dann sozusagen der Bauplan für Objekte die wir erstellen können. Das heißt was wir hier machen ist festzulegen was für Eigenschaften Objekte von dieser Klasse haben also welche Attribute und auf der anderen Seite welche Operationen sie haben sprich was Objekte dieser Klasse machen können. Wir hatten im letzten Video dieses Studierenden Beispiel das habe ich jetzt einfach hier weiter mitgenommen. Wir könnten uns jetzt überlegen was haben Studierende also welche Attribute da haben wir gesagt Name alter Matricle Nummer ich habe jetzt noch was Neues hinzugefügt und zwar ein Lieblingsmodul und auf der anderen Seite legen wir fest oder überlegen wir uns was Studierende machen können hier können wir sagen Studierende können lernen Geburtstag feiern und und und das wären die Operationen und auf der anderen Seite eben die Attribute also die Sachen die Studierende haben die Sachen die Studierende können.

Ich würde sagen wir springen direkt in den Code und ich habe jetzt hier Visual Studio Code laufen. Sinnigerweise stelle ich erstmal eine Datei die nenn ich Student.java und freundlicherweise wird mir jetzt hier schon so ein bisschen was ergänzt die sind tags kennen wir auch schon also das hatten wir von Anfang an eigentlich drin Klass Student ist würde ich sagen relativ selbst erklärt über dieses Public spreche ich später nochmal wichtig ist ich schreibe Klassen in Java groß und der Dateiname hier abgesehen natürlich von diesem Punkt Java entspricht dem Klassen Namen hier also Student und Student Punkt Java. Okay dann hatten wir gesagt Studierende haben irgendwelche Attribute die würde ich jetzt hier direkt mal aufnehmen und vorab eine kleine Warnung oder ein Hinweis über Sichtbarkeiten also zum Beispiel dieses Public hier oben und eben noch Sichtbarkeiten von Attributen beziehungsweise von Methoden von Operationen spreche ich in einem anderen Video ich halte jetzt hier wirklich ganz minimalistisch und sage einfach nur Studierende haben einen Namen ein Name werfen Datentypen string wie gesagt das ist noch nicht ganz fertig weil wir da in einem anderen Video noch drüber gucken was man hier genau machen würde in java klassischerweise für dieses Video soll es einfach reichen das genauso zu formulieren wie gesagt string Name Alter wäre Die Matrixnummer wäre dann wieder ein String. Und dann hatten wir noch gesagt, es gibt ein Lieblingsmodul. Das würde ich jetzt hier erstmal auskommentieren, weil wir das ohne weiteres jetzt nicht darstellen können in Java. Also zumindest nicht mit einem primitiven Datentypen. Und dann hatten wir hier gesagt, Studierende können lernen bzw.

Geburtstag feiern. Auch hier, dieser Hinweis, dass das alles hier noch ohne Sichtbarkeiten ist, zieht sich quasi über die ganze Klasse jetzt durch. Würde ich auch erstmal sagen, wir legen die Methoden an ohne Sichtbarkeiten. Das heißt, wir sagen, void, learn.

Und jetzt zeige ich eine coole Sache in Visual Studio. Wenn ich einfach nur sage, es out und auf Tab drück ergänzte mir hier ein System on Print Line. Ich will jetzt die Methode hier nicht wirklich implementieren, sondern wir deuten einfach nur an, dass was passiert. Und genau dasselbe mit Geburtstag feiern. Auch hier würde ich keinen Returnwert erwarten. Deswegen, ja, das sagen wir einfach, void. Wichtig ist, hier, da gibt es auch noch mal ein extra Video dazu bald. Lassen wir dieses Keyword Static, was wir bis jetzt verwendet haben, weg, weil wir uns eben im Bereich der Objektorientierung bewegen. Wie gesagt, Auflösung in einem anderen Video. Auch hier deutlich nur an, dass eben irgendwie Geburtstag gefeiert wird. Wunderbar. Sehr schön.

Okay. Das hier oben wären jetzt erstmal die Attribute dieser Klasse. Also das, was Objekte haben und auf der anderen Seite hier unten die Operationen.

Also das, was Objekte, die nach diesem Bauplan in Anführungszeichen erstellt werden, eben können. Studierende können lernen Geburtstag feiern und Studierende haben einen Namen, einen Alter usw. Jetzt haben wir hier noch eine Sache ausgelassen, und zwar diesen Lieblingskurs, dieses Lieblingsmodul. Und hier ist natürlich die Frage, wie würden wir das darstellen?

Wir können nicht ohne weiteres String nehmen, weil zum Beispiel zu einem Lieblingsmodul gehören könnte, wie viele Plätze sind da, und wie heißt dieses Modul und so weiter und so fort, wie viele ECTS, keine Ahnung, können wir beliebig modellieren. Aber wir kommen irgendwie nicht wirklich weit mit den primitiven Datentypen. Also nicht mit Int, String ist es streng genommen, kein primitiver Datentyp. Aber mit den Datentypen, die wir kennen, kommen wir irgendwie nicht so weit. Und was wir hier machen würden, ist eben ganz einfach, einen neuen Datentypen anzulegen, sprich eine neue Klasse. Wie gesagt, Klasse ist ein neuer Datentypen-Java.

Das heißt, hier würde ich eine neue Datei anlegen und würde sagen, das ist ein Kurs, Punkt Java. Auch hier wird wieder freundlicherweise was ergänzt. Und wir sagen jetzt einfach, der Kurs hat einen Namen und der Kurs hat keine Ahnung, eine maximale Anzahl an Studierenden bzw. an Plätzen, wie da frei sind. Und diesen Datentypen hier könnte ich nun in meiner Student-Klasse verwenden, um wiederum andere Attribute darzustellen.

Ja, also ich bin hier nicht darauf angewiesen, nur Int, String, Bullien, was auch immer wir kennen, zu verwenden, sondern ich habe eben auch die Möglichkeit, hier wie am Beispiel von diesem Kurs, einen extra Datentypen anzulegen und den dann entsprechend hier zu verwenden, um zu sagen, mein Attribut Lieblingskurs ist eben vom Datentypen Kurs. Okay, so viel dazu. Und dann sehen wir uns in den folgenden Videos an, wie wir mit Objekten arbeiten können bzw. erstmal Objekte erstellen können anhand von dieser Klasse und nochmal hier der Hinweis, ja, wir gucken uns auch noch Sichtbarkeiten an, das hier ist noch nicht ganz fertig, also noch nicht blind übernehmen. Das funktioniert zwar vielleicht schon, ist aber noch nicht der, sage ich mal, 100% richtige Weg in Java, da fehlt noch eine Kleinigkeit. Kommen wir dann in einem anderen Video dazu. Okay, bis dahin.



Objekterzeugung

weiter geht es mit dem Thema Objektorientierung. Im letzten Video hatten wir uns angesehen, wie Klassen in Java angelegt werden. Hier sehen wir uns dementsprechend an, wie wir konkrete Objekte anzeugen können.

Wie sieht das konkret in Java aus? Wir lernen dabei Konstruktoren kennen und schauen uns ein bisschen an, wie wir damit arbeiten können, wie wir die vielleicht noch anpassen können. Und gegen Ende des Videos möchte ich auf Null zu sprechen kommen. Das ist quasi allgegenwärtig in Java, gerade wenn man sich mit Objekten beschäftigt, was es damit genau auf sich hat. Sehen wir sofort. Vielleicht nochmal ganz kurz zur Wiederholung. Objekte sind nichts anderes als Instanzen einer Klasse. Das heißt ganz konkrete Exemplare folgen dabei natürlich diesem Baubla an der Klasse. Im letzten Video hatten wir die Klasse Student angelegt und festgelegt. Studierende haben einen Namen, einen Matrikelnummer, einen Alter und so weiter und so fort. Wenn wir jetzt aber ganz konkrete Objekte uns ansehen, also hier zum Beispiel unsere beiden Studierenden aus dem ersten Video, Alice und Bob, sind diese Antribute völlig anders ausgeprägt. Also Alice hat den Namen Alice, Bob hat den Namen Bob.

Die beiden haben ein anderes Alter, eine andere Matrikelnummer und so weiter und so fort. Also ganz ganz unterschiedliche Charakteristiken, ganz verschieden ausgeprägte Attribute. Wie sieht das Ganze in Java aus? Wenn ich ein Objekt erzeugen möchte, mache ich das, indem ich einen Konstruktor aufrufe bzw. Schlüsselwort New verwende. Ganz kurz dahin weiß, das ist jetzt hier zwar die offizielle Folie, in der das einmal vorgestellt wird. Allerdings hatten wir gegen Anfang des Semesters zum Beispiel auch den Scanner verwendet. Deswegen ist es jetzt nicht das aller allererste Mal, dass ihr diese Sünden tag seht. Wie gesagt, hier nur die offizielle Erklärung, was es damit auf sich hat. Ich gehe diesen Coaching-Hipsel unten mal so ein bisschen von rechts nach links durch.

Wie gesagt, wir rufen den Konstruktor auf. Das ist nichts anderes als eine spezielle Methode zum Erstellen eines Objekts. Die Methode hat genau denselben Namen wie die Klasse. Unter dem Fall hier ist dieser Konstruktor parameterlos.

Das heißt, in diesen runden Klammern steht nicht noch irgendwie ein Wert, der entsprechend übergeben wird. Es handelt sich hierbei um den sogenannten Default-Konstruktor. Was man hier noch machen kann, sehen wir uns sofort an. Dann haben wir das Schlüsselwort New.

Wie gesagt, zum Erzeugen von Objekten. Und jetzt hier auf der linken Seite von dem Ist-Gleich haben wir ganz klassisch, das kennt ihr schon, den Typen für unsere Variable. Wir geben in Java immer an, welchen Datentyp hat meine Variable überhaupt. Und wenn das eben ein benutzerdefinierter Datentyp ist, gebe ich eben entsprechend den Namen der Klasse an. Hier, meinetwegen Sam class. Wenn wir jetzt mal wieder an dieses studierenden Beispiel gehen, dann wäre es eben der Datentyp Student. Und dann geben wir noch an, ja auch hier völlig bekannt schon, welche Namen hat die Variable. Der Unterschied ist hier, das ist eine Variable, die sozusagen nur auf ein Objekt zeigt, also eine Variable, die eine Referenz auf ein Objekt darstellt.

Was es damit auf sich hat, komme ich dann gegen Ende des Videos, beziehungsweise auch noch mal in einem Extra-Video drauf zu sprechen. Wie kann ich dann, wenn ich so ein Objekt erstellt habe, auf die Operationen an das Objekt zu greifen? Das ist nicht ganz neu, weil er zum Beispiel bei Scanner gesagt hat, Scanner Next-Int oder Scanner Next-Line oder was auch immer, mit diesem Punkt-Operator, das heißt, ich gebe den Namen der Variable an und dann den Namen der Methode, beziehungsweise ruft die Methode auf mit diesem Punkt-Operator dazwischen. Diese Methode wird dann eben ganz konkret für dieses eine Objekt aufgerufen oder angewendet. Hier zum Beispiel lege ich eine neuen Studierende, Person an, Student Student ist New Student.

Hier jetzt bitte auf die großen und Kleinschreibung achten, ja Student mit großem S ist natürlich die Klasse, beziehungsweise der Konstruktoraufruf, und mit dem Kleinen S ist es die Variable mit dem Namen Student, könnte ich auch anders benennen, und dann sage ich Student Punkt Learn und rufe eben für genau diese eine Studierende Person, die da angelegt worden ist, die Methode in Learn auf. Gucken wir uns noch mal ganz kurz Konstruktoren an. Wir hatten ja bis jetzt immer nur parameterlose Konstruktoren, das heißt, ein Konstruktor, wo wir nicht extra noch was übergeben. Dafür muss ich nicht unbedingt irgendwas machen. Java legt den im Hintergrund automatisch an und ich kann diesen Default Konstruktor dann nutzen, um Objekte anzulegen. Ich kann auch explizit so einen solchen Konstruktor definieren und das ist das Code Beispiel dafür.

Ich würde einfach sagen Public Student, Runde Klammern, geschweifte Klammern, da drin passiert jetzt absolut nichts und das wäre letzten Endes genau das, was Java im Hintergrund sowieso für mich anlegt. Aufrufen würde ich es dann wie hier auf der rechten Seite auch gezeigt, indem ich sage New Student. Auf der anderen Seite habe ich die Möglichkeit, Konstruktoren auch direkt mit Parametern anzulegen. Das mache ich üblicherweise dann, wenn ich zum Beispiel direkt beim Erstellen ein Attribut setzen möchte.

Also direkt zum Beispiel hier für Studierende, die ich anlegenden Namen übergeben möchte und dann könnte ich eben sagen, this.name ist gleich name. Was es mit diesem wiss auf sich hat, sehen wir sofort in einem anderen Video. Sondern es jetzt nicht zu sehr aufhalten, führt aber dazu, dass ich eben, wenn ich einen solchen Konstruktor aufrufe, den Namen oder einen String mit übergeben muss. Okay, ich würde sagen, wir gucken uns das ganze mal im Code an, einfach um es einmal gemacht zu haben.

Wir haben hier unsere wunderschönen Klassen vom vorherigen Beispiel und was ich jetzt machen würde, ist mal eine neue Datei, eine neue Klasse anzulegen, Main, wo ich jetzt hier einfach nur die Main-Methode reinpacken werde, um mal ein bisschen was auszuprobieren. Okay, ja, wir legen hier mal zwei Studierende Personen an oder eine reicht eigentlich auch aus, nehmen wir mal Alice. und wir können jetzt eine Methode für eine Operation von diesem neu angelegten Objekt aufrufen, Alice.learn. Das ist die Methode hier, die wir im letzten Video erstellt haben.

Learn. Wenn ich das Ganze jetzt mal ausführe, dann müsste ich hier auf der Konsole sehen. Wunderbar. Okay, das ist jetzt hier der Konstrukteuraufruf. Wenn wir in die Klasse reingucken, sehen wir, es wurde nicht expliziten Konstrukteur angelegt. Ich könnte das jetzt mal Spaßes halber machen, dass ich sage, ich nehme auch gleich eine Sichtbarkeit dazu.

Public, Student, Gründerklammern, geschweifte Klammern. Und hier würde sich absolut nichts ändern, auch wenn ich den Code ausführe, ändert sich absolut nichts. Das ist jetzt nur noch mal explizit ausgeschrieben, was Java im Hintergrund für mich anlegen würde, wenn ich nicht expliziten ein Konstrukteur anlege. Und jetzt können wir mal das machen, was wir auch in den Folien gerade hatten, nämlich dass ich sage, ich lege einen Konstrukteur an mit einem Wert der übergeben werden soll mit diesem Name.

Diesen Namen möchte ich von Anfang an setzen, also bei der Objekterstellung schon direkt einen Namen verlangen und den dann entsprechend für das Objekt setzen. Während ich hier gespeichert habe, habt ihr vielleicht gesehen, hier ist was rot geworden. Das funktioniert dann so hier natürlich nicht mehr. Also hier würde dann erwartet werden, dass ich eben einen Wert übergebe, das wäre meinetwegen alles.

Und dann würde dieser Wert automatisch gesetzt werden, soweit ich das Objekt erstelle. Ich kann jetzt hier vielleicht auch mal das ein bisschen eindeutiger zu machen, bei den beiden Methoden einfach sagen, bitte den Namen ausgeben, so Name, Learn und Name, Geburtstag einfach nur damit eindeutig ist, zu wem das gehört. Wenn ich das dann ausführe, würde ich hier sehen, Alice, Learn. Wunderbar, wenn ich ein zweite Person anlege, ich kann das ja mal, na wobei, ich leg das einfach neu an, Student, Bob ist gleich ein new Student. Und dann lassen wir Bob lernen, also Bob.Learn, dann müsste ich jetzt auf der Konsole sehen, einmal natürlich von hier oben noch Alice und dann Bob.

Wunderbar. Also diese Namen werden jetzt direkt beim Anlegen des Objekts mit übergeben und dann im Konstrukte oder über den Konstrukte automatisch gesetzt. Ich hatte gesagt, ich komme noch auf eine Kleinigkeit zu sprechen, nämlich auf Null, bzw.

erklär ganz kurz, was es damit auf sich hat. In Java haben wir primitive Datentypen, die haben wir am Anfang des Semesters kennengelernt, als es ich Boolean in Double Float, bei alles Mögliche, Character. All diese Datentypen sind primitiv, die schreibe ich in Java klein. Auf der anderen Seite haben wir komplexe Datentypen, also großgeschriebene Datentypen, die funktionieren ein bisschen anders.

Strings gehören auch zu den komplexen Datentypen, also Strings sind in Java nicht primitiv, haben aber noch mal so ein bisschen, wie soll ich sagen, so einen Platz zwischen den primitiven und den komplexen Datentypen. Ganz eindeutig ist es natürlich, wenn wir Klassen anlegen. Also das sind eindeutige Referenzdatentypen, eindeutige komplexe Datentypen und in diesem Begriff Referenzdatentypen steckt eigentlich auch schon das, was der entsprechende Unterschied ist. Ich komme im extra Video noch dazu, aber jedes Mal wenn ich ein Objekt anlege, wird im Speicher irgendwas erstellt und diese Variable hier Alice zum Beispiel zeigt dann auf dieses im Speicher angelegte Objekt. Es ist also nur eine Referenz auf ein Objekt, anders als beim primitiven Datentypen, wo dann quasi in der Variable direkt der Wert abgespeichert wird. Wenn ich jetzt nicht so eine solche Referenz habe auf ein Objekt, wenn ich jetzt zum Beispiel, wenn wir hier scharf auf diese Klasse gucken, wir haben den Namen jetzt zwar gesetzt, aber hier diesen Kurs, mit dem haben wir noch gar nichts gemacht, der ist einfach nicht da. Das heißt im Umkehrschluss, da ist nicht der Kurs nicht da, sondern die Referenz auf einen angelegten Kurs ist einfach noch nicht gesetzt und hier würden wir, könntest du mal probieren, auf der Konsole auszugeben.

Hier würden wir dann, ich zeige auch eine coole Sache, wenn ich es out schreibe und dann auf Tab drückt, dann wird mir automatisch das System on Print line generiert. Ich kann ja jetzt mal probieren zum Beispiel von Bob, den Lieblingskurs mir ausgeben zu lassen und würde dann hier auf der Konsole Null sehen. Null sagt eben genau das aus.

Hier fehlt eine Referenz, hier ist kein Objekt irgendwie auf das gezeigt wird, was diesen Lieblingskurs ausdrücken soll. Könnte ich natürlich alles noch machen. Ganz kleiner Hinweis, das ist auch noch nicht die finale Schreibweise, wie ich das in Java machen würde. Ich schreibe direkt dran. Hinweis, so wie ich das nennen.

So rufen wir Attribute in Zukunft nicht auf. Komm ich gleich in einem extra Video noch dazu. Egal, für dieses Beispiel reicht es völlig aus und was wir sehen ist eben, wir haben noch keinen Kurs angelegt. Ja, also es gibt noch keinen Kurs, der irgendwie hinterlegt ist. Dieser Referenz ist eben einfach nicht da und das ist alles, was dieses Keyword Null letzten Endes aussagen soll. Ich würde sagen, damit sind wir hier am Ende und in den nächsten Videos steigen wir dann noch ein bisschen tiefer ein.



Privatsphäre und Sichtbarkeiten, Encapsulation, Getter & Setter

Weiter geht es mit den Grundlagen der Programmierung bzw. mit Objektorientierung. Wir steigen einfach ein bisschen tiefer ein. Wir hatten jetzt Klassen und Objekte kennengelernt. Hier unglaublich sperriges Thema, sperriger Titel, Privatsphäre und Sichtbarkeiten, Encapsulation, Getter und Setter. Keine Sorge, wirkt erst mal erschlagend, gehört aber natürlich alles zusammen. Wir wollen uns ansehen, was gibt es in Java für Sichtbarkeiten? Was ist dieses Prinzip der Encapsulation bzw.

was ist das Prinzip von Information Hiding? Im Rahmen dessen werden wir die Notwendigkeit sehen, Getter und Setter zu nutzen bzw. uns erst mal angucken. Was ist das überhaupt? Was hat es damit überhaupt auf sich? Ein Wort, was wir im letzten Video schon hatten, ist dieses This.

Wenn ihr euch erinnert, das war, wo wir ein Konstruktor mit Parabitern definiert haben und gesagt haben, this.name ist gleich name, also der Name, der an den Konstruktor oder per Konstruktor übergeben wird, soll automatisch auch gesetzt werden als Attribut. Da kam dieses This zum Einsatz. Wir haben es aber noch nicht weiter erklärt. Und das bietet sich hier auch super an.

In Java gibt es im Grunde vier Sichtbarkeiten. Die Defaultsichtbarkeit Protected Public und Private. Default und Protected gucken wir uns hier gar nicht weiter an. Das kommt einem nächsten Semester in Prop 2, sondern wir gucken nur auf Public, also öffentlich und private, sprich privat oder verborgen oder wie auch immer. Wichtig ist, ein Prinzip zu verstehen in der beaktorientierten Programmierung, und zwar das Prinzip der Datencapsulung bzw.

Encapsulation. Das sagt einfach nur aus, wir wollen innerhalb von einer Klasse Attribute und Methoden bündeln und so wenig wie möglich nach außen Preis geben. Das heißt, erst mal alle Daten vor Abrufen bzw. vor Veränderungen durch andere Klassen schützen und auch jegliche Implementierungs-Sitals von Methoden, wie gesagt, so weit wie möglich verbergen. Das heißt, ich verwende, technische Umsetzung dessen ist einfach, ich verwende das Schlüsselwort Private, die Sichtbarkeit Private, so weit wie es eben geht.

Prinzip dahinter nennt sich Information Hiding und auf der anderen Seite würde ich eben für die Sachen, die wirklich von außen aufrufbar sind, die Sichtbarkeit Public verwenden und damit eben eine ganz, ganz klare, eigentlich möglichst kleine Schnittstelle nach außen wirklich öffentlich Preis geben und den Rest verbergen. Ich würde sagen, wir machen das einmal gemeinsam im Code. Wir hatten gesehen, Attribute sind grundsätzlich auf Private gesetzt. Ich füge das hier mal einfach ein, Private String und ist ein bisschen mühsam für 4, weil ich kriege es hin und auf der anderen Seite wollen wir bestimmte Schnittstellen nach außen festlegen. Also hier dann das Schlüsselwort Public verwenden, einmal natürlich hier der Konstruktor, ganz klar.

Wir wollen ja von einer anderen Klasse aus Studierende anlegen können und auch diese Methoden hier würde ich jetzt sagen, haben die Sichtbarkeit Public verdient, weil ich die ja von außen aufrufen will. Ich habe auch natürlich trotzdem die Möglichkeit, also es soll hier nicht der Eindruck entstehen. Attribute sind immer Private, Konstruktoren sind in der Regel Public, aber Methoden sind immer Public und Attribute sind immer Private, das nicht. Ich habe trotzdem die Möglichkeit hier zum Beispiel eine internen Implementierung zu haben, zum Beispiel LearnKeeper, glaube ich auch immer, und dann zu sagen, wie auch immer, diese Methode dann innerhalb von der Public-Methode aufzurufen. Das heißt nach außen hin, Sichtbar wäre sozusagen nur diese Methode Learn, wie das aber konkret implementiert ist innerhalb meiner Klasse, dass es mir überlassen und ich kann dafür natürlich auch Methoden zur Verfügung stellen, die ich eben nicht von außen aufrufen kann, aber die innerhalb der Klasse verwendet werden können.

Wenn man jetzt scharf hingeguckt hat, hat man gesehen, diese Klasse Main hier hat irgendwie einen Fehler bekommen, und zwar hier unten an der Stelle, wo ich auch schon den Hinweis hingeschrieben habe, so wird das gar nicht aufgerufen in Zukunft. Wir haben jetzt dieses Attribut, FIFCURSE, also Lieblingsmodul, auf Private gesetzt und damit eben verhindert, dass von außen auf dieses Attribut zugegriffen werden kann. Jetzt mag sich vielleicht irgendjemand die Frage stellen, gut, aber was ist, wenn wir von außen eigentlich, also von außen, damit meine ich von einer anderen Klasse aus, diesen Kurs irgendwie sehen wollen oder irgendwie damit weiterarbeiten möchten. Hier springe ich zurück zu den Folien. Wir lösen das, indem wir nichts anderes machen als Methoden für genau diesen Zweck, also einmal zum Lesen eines Attributwärts und einmal zum Verändern eines Attributwärts anzulegen.

Die haben auch ein ganz klares Namensschema, nämlich GET bzw. SET, also GETTER-Methoden bzw. SETTER-Methoden.

Und die machen nichts anderes, erst mal hier links unten die GETTER-Methode, als ein Attribut zurückzugeben und eben wie gesagt, GET NAME, das Namensschema ist hier schon relativ selbstecklerend oder eben auf der anderen Seite SET NAME und dann Attributwärts zu ändern. Hier sehen wir auch dieses WISS wieder. Ich komme dann sofort zurück, was es damit genau auf sich hat. Ich würde es einmal machen, springe hier zum Code zurück. Ich mache mal folgendes, dieser Kurs, das hatte ich ja vorhin gezeigt, um NAL zu verwenden. Das würde ich jetzt mal sein lassen und würde sagen, keine Ahnung, wir machen, wir geben noch die Möglichkeit, das Alter anzulegen und wollen dann damit einmal ein GETTER und einmal ein SETTER für dieses Attribut H schreiben und sagen Public GET H, ja, sorry, Public INT GET H. Ja, wir geben natürlich einen Integer zurück, weil das Attribut hier oben ein Integer ist. Macht nichts anderes als zu sagen RETURN H bzw.

hier. würden wir sagen PublicWordSetAge würden einen Wert reingeben, der Wert ist natürlich vom DatentypInt und würden dann sagen, das Punkt H ist gleich H. Keine Sorge, dieses Erklär ich in 1, 2 Minuten, was es damit genau auf sich hat. Jetzt hätte ich hier die Möglichkeit, ja, für meinen Bob meine Dwegen zu sagen, Bob hat ein bestimmtes Alter und das würde ich machen, ich kriege ja hier auch schon immer vorgeschlagen, was es für Methoden gibt und hier müsste irgendwo genau, z.H. stehen. Diese Methode z.H. kann ich aufrufen, ich sage jetzt mein Dwing 19 Jahre alt und dann können wir auch mal auf der Konsole ausgeben, wie alt Bob ist, bzw. uns dieses Alter zurückgeben lassen, indem wir sagen Bob Punkt Get H. Ich führe das ganze mal aus, ja, scheint zu funktionieren. Also dieses Learn, Learn, Learn, was ich vorhin eingefügt habe, wird natürlich auch mit ausgegeben, mehr kurze Erinnerungen werden hier gesagt, ich kann in einer PublicMethode natürlich trotzdem beliebig viele PrivateMethode intern aufrufen, deswegen sehen wir hier trotzdem Learn, Learn, Learn auch für Alice oben und hier diese Getter und Setter, ja, also die Möglichkeit, einen Wert zu bearbeiten, nämlich dieses Alter, aber eben nicht explizit, indem wir auf das Attribut zugreifen, sondern indem wir die Schnittstelle von unserer Klasse Student aufrufen, in Form von einem Getter bzw.

von einem Setter, der dann eben irgendwas mit diesem Attributwert macht, sprich, liest oder den Wert irgendwie verändert für uns. Aber wir haben nicht direkt Zugriff hier drauf. Das ist das ganze Prinzip.

Jetzt sehen wir hier, gibt es einen Schlüsselwort dieses This, ich spring noch mal ganz kurz zurück zu den Folien, ich habe dazu auch eine kleine Folie dabei. This ist nichts anderes als eine Referenz auf das aktuelle Objekt, das gibt es erst mal relativ sperrig. Was hat es damit auf sich?

Ich kann this immer nutzen, um direkt Instanzvariablen von einem Objekt zum Beispiel aufzurufen, also zu sagen this.name und es gibt Stellen, wo ich das machen muss, es gibt Stellen, wo es quasi mir überlassen ist, ob ich das verwenden will oder nicht. Beides gucken wir uns jetzt an. Ich finde, um ehrlich zu sein, es spricht eigentlich wenig dagegen dieses This auch dann zu verwenden, wenn ich es nicht unbedingt brauche. Also wenn implizit quasi schon das, was ich in Anführungszeichen erwarten würde, getan würde, schade ich mir vielleicht trotzdem nicht explizit this hinzuschreiben, um ein bisschen zu verdeutlichen, worum es überhaupt geht. Ich zeige sofort, wo das Problem liegen könnte. Nehmen wir uns mal diese Methode, set age hier oder auch hier oben diesen Konstruktor, mit this.name ist gleich name. Hier haben wir letzten Endesjahren einen kleinen Namenskonflikt und zwar haben wir hier einen string mit dem Namen name bzw. mit dem Namen age und wollen den für den Wert hier oben setzen. Und wenn ich jetzt das hier hinschreiben würde, name ist gleich name, das wird mir auch schon orange hier irgendwie unterkringelt, hat das am Ende des Tages kein Effekt, weil er sagen würde, ich weise diesem string hier den Wert von name zu. Also es ist irgendwie quatsch.

Was ich machen will oder was ich ja eigentlich verändern will, ist diesen Wert hier oben. Also ganz konkret die Instanzvariable, das Attribut meines jeweiligen Objekts und wenn ich mich auf das hier oben beziehen will, sage ich eben ganz explizit this.name, damit ist immer mein Attribut hier oben gemeint bzw. hier this.age entsprechen diese Variable, also Instanzvariable age. Ansonsten würde er immer nur davon ausgehen, naja es ist halt dieses age bzw. hier dieses name, was übergeben wird gemeint, wenn ich dieses this weglas passiert letzten Endes gar nix, weil ich eine Variable den Wert zu weiss, den sie schon hat und mit der Variable passiert hier sowieso nichts mehr. Deswegen brauche ich dieses this.

Es gibt Stellen wie zum Beispiel hier bei dem return age bzw. hier wo ich name immer reingeschrieben habe, wo ich nicht explizit schreiben muss, this. Das liegt daran, dass es hier keine Variable oder kein Parameter gibt mit dem Namen und dementsprechend Java weiss, okay wenn hier name steht, wird schon das hier oben gemeinsam, gibt ja keine Alternative. Hier ist die Möglichkeit, also hier habe ich die Möglichkeit trotzdem noch ein this hinzuschreiben, wenn ich will, indem ich zum Beispiel sage this.name, das würde letzten Endes nichts ändern, ist aber halt noch mal ein bisschen expliziter, dass es sich auf dieses Attribut hier oben bezieht, weil mit this immer klar ist, this.blablabla, bezieht sich auf irgendein von diesen Attributen, während name hier zum Beispiel eben ja der Parametername für name ist. Und um hier einen namenskonflikt irgendwie zu vermeiden oder nicht zu unerwarteten Verhalten von Programmen irgendwie zu kommen, verwenden wir dieses this und wie gesagt es gibt Programmiersprachen, in denen man auch immer, also auch hier unten wo es eigentlich implizit klar ist, dass der name hier oben gemeint ist, this setzen müsste, in Java muss ich das nicht, aber es ist eigentlich nicht unbedingt schlecht, wenn ich hier zum Beispiel auch sagen würde, this.name, weil dann ganz explizit klar ist, wir meinen halt diesen Namen von hier oben. So viel dazu und dann würde ich sagen, steigen wir im nächsten Video noch ein bisschen tiefer ein.



Umgang mit Referenzdatentypen

Um den ersten Block an Themen zu Objektorientierung abzuschließen, gucken wir nochmal genauer auf dieser Referenz-Daten-Typen. Das heißt, wir möchten uns ansehen, wie Objekte in Java gespeichert werden, im Gegensatz zu primitiven Werten und was es dann im Umkehrschluss zu beachten gibt, wenn wir damit arbeiten. Hier nochmal so eine Art Wiederholungsfolie. Ich hatte es auch schon mal in einem anderen Video so ein bisschen zumindest erwähnt, was es dafür Unterschiede gibt.

Wenn wir mit dem Keyword New ein neues Objekt anlegen, legen wir eben ein neues Objekt im Speicher an. In dem Moment, wo wir mit irgendeiner Variable oder mit einem Parameter arbeiten, haben wir am Ende des Tages nur eine Referenz, einen sogenannten Pointer auf ein solches Objekt im Speicher. Das heißt, hier unten dieses, ein Anführungszeichen Code Beispiel, da sagen wir, wir haben eine Studentin Alice und Student Alice ist gleich irgendwas, New Student schätzungsweise. Dabei würden wir ein neues Objekt anlegen, aber in dieser Variable Alice hätten wir letzten Endes nur eine Referenz auf dieses Objekt.

Im Gegensatz dazu bei primitiven Datentypen haben wir eben direkt diesen Wert quasi in der Variable gespeichert. Wir sehen uns einfach mal direkt an, was das ganz konkret für uns bedeutet, wenn wir programmieren. Ich habe hier mal eine Main Methode, die Student und die Kursklasse habe ich mal behalten weiter und ich übernehme einfach mal kurz das Beispiel aus der Folie. Wir haben hier erstmal einen Integer und wir haben eine Studentin, hier müssen wir einen Namen übergeben, können wir gerne machen. Wir setzen für Alice auch schon mal direkt das Alter, was habe ich mir gesagt, ich glaube 23.

Spiele auch eigentlich keine große Rolle. Okay, vielleicht so ein bisschen als Wiederholung, wenn ich jetzt hier eine neue Variable anlegen will, neuen Integer und sage j ist gleich i, würden wir ja, das ist auch mal auf der Konsole aus, würden wir hier sehen, okay ja j hat den Wert 123, wenn ich hier was machen würde wie j mal gleich oder plus gleich, was auch immer, 456, würden wir eben entsprechend den neuen Wert für j auf der Konsole sehen. Wenn ich jetzt hier unten allerdings sage, also nachdem ich hier die neue Variable angelegt habe und dann auch noch was dazugezählt habe, bitte gib mir mal i, das heißt das von hier oben aus, dann würden wir hier immer noch die 123 sehen. Wir arbeiten also mit den ganz konkreten Werten in dem Fall. Bei den Objekten, mit denen wir jetzt angefangen haben, sieht das alles ein bisschen anders aus. Wir legen hier genau einmal ein Objekt an, so als Faustregel, jedes Mal wenn nu da steht, legen wir auch ein neues Objekt im Speicher an und diese Variable Alice hier zeigt quasi auf dieses eine Objekt im Speicher. Das heißt, wenn ich jetzt hier unten sagen würde, ich leg eine neue Variable an und um jetzt hier nicht durch Namen irgendwie auseinanderzukommen, dann lege ich einfach mal Alice Referenz 2 und hier sage ich einfach, das ist Alice. Alles was hier passiert ist, dass ich quasi einen zweiten Pointer, eine zweite Referenz auf das selbe Objekt im Speicher erstell, also auf genau dieses Objekt, was wir hier angelegt haben.

Und wenn ich dann hier zum Beispiel sagen würde, Alice Ref 2.0. wenn ich einfach mal sagen, ich möchte mir von LSref2 das Alter ausgeben lassen, dann würde ich entsprechend auch hier die 23 sehen. Liegt wie gesagt daran, dass wir dieses Objekt hier erstellt haben. Das ist das einzige Objekt, was wir in dem Code erstellen. Dieses Objekt liegt im Speicher. Für dieses Objekt wird dann das Alter gesetzt und hier legen wir lediglich eine neue Referenz an und am Ende des Tages, wenn wir zwar mit der neuen Referenz, aber trotzdem für das selbe Objekt, uns das Alter ausgeben lassen, dann ist es eben 23, so wie wir das hier oben gesetzt haben. Wir spinnen das Ganze noch mal ein Stück weiter und was ich jetzt zeigen will, ist, wir legen einfach eine Methode an, PrivateVoid, keine Ahnung, DuplicateInt, die Methode nimmt irgendwie eine Zahl entgegen und alles, was sie macht, ist num mal gleich 2.

Wir rufen die Methode mal auf und zwar für oder mit i, wir übergeben direkt i, wir sagen also, hier habe ich noch ein Statik vergessen, wir sagen DuplicateInt übergeben i und wollen uns dann auch mal i auf der Konsole ausgeben lassen. Was kommt daraus? Weiterhin diese 123, also der Wert von hier oben. Das liegt eben daran, dass auch hier letzten Endes eine Kopie bzw.

einfach der Wert als solcher übergeben wird, nicht aber eine Referenz auf irgendwas im Speicher. Wenn wir jetzt eine andere Methode schreiben, die relativ ähnlich aussieht und die heißt DuplicateAge, was vielleicht ein bisschen komischer Use Case ist, aber für unser Beispiel ganz gut und hier geben wir eben einen Objekt von der Klasse Student rein und alles, was wir hier machen ist, zu sagen, Student.setAge und der Wert wäre einfach Student.getAge, also das Alter dieses Objekts oder dieses Studenten, dieser Studentin und multiplizieren das mal 2. Den ich das aufrufe mit unserer Alice, das ist jetzt im Grunde auch egal, ob wir Alice ref2 oder Alice von hier oben übergeben und danach mir das Alter von Alice ausgeben las, ich nehme jetzt mal konsistenterweise auch diese ref2 hier, dann würde ich sehen, also ich habe hier versehentlich nicht getAge geschrieben, das würde irgendwas ausgegeben, womit wir nicht so viel anfangen können. Genau, wir sehen jetzt hier, es wird 46 ausgegeben und das liegt eben daran, eigentlich genau dasselbe, was ich vorhin gesagt habe, wir haben genau ein Objekt, das wird hier angelegt. Auf dieses Objekt haben wir mehrere Referenzen, einmal die hier, dann haben wir hier eine zweite Referenz auf das Objekt erstellt und wenn wir hier Alice ref2 übergeben, übergeben wir auch nur diese Referenz, das heißt dieser Student hier, zumindest wenn wir Alice ref2 übergeben, schaut eben letzten Endes auch auf genau dieses Objekt hier oben und wenn wir dann das Alter verdoppeln, dann verdoppeln wir das für genau dieses eine Objekt, was wir hier angelegt haben. Das ist so ein bisschen der Unterschied zwischen primitiven und komplexen Datentypen, muss man immer beachten, weil das natürlich oft auch irgendwie zu Fragezeichen führt, warum hat sich jetzt meine Zahl hier verdoppelt oder auf der anderen Seite nicht und die Antwort ist eben, das liegt daran, wie die Objekte oder wie die Daten in Java gespeichert werden. Damit würde ich sagen, haben wir einen guten Teil geschafft, Objektorientierung Part 1 und ja, der Rest kommt dann in der kommenden Woche.